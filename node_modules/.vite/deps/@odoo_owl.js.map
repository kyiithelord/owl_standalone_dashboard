{
  "version": 3,
  "sources": ["../../@odoo/owl/dist/owl.es.js"],
  "sourcesContent": ["function filterOutModifiersFromData(dataList) {\r\n    dataList = dataList.slice();\r\n    const modifiers = [];\r\n    let elm;\r\n    while ((elm = dataList[0]) && typeof elm === \"string\") {\r\n        modifiers.push(dataList.shift());\r\n    }\r\n    return { modifiers, data: dataList };\r\n}\r\nconst config = {\r\n    // whether or not blockdom should normalize DOM whenever a block is created.\r\n    // Normalizing dom mean removing empty text nodes (or containing only spaces)\r\n    shouldNormalizeDom: true,\r\n    // this is the main event handler. Every event handler registered with blockdom\r\n    // will go through this function, giving it the data registered in the block\r\n    // and the event\r\n    mainEventHandler: (data, ev, currentTarget) => {\r\n        if (typeof data === \"function\") {\r\n            data(ev);\r\n        }\r\n        else if (Array.isArray(data)) {\r\n            data = filterOutModifiersFromData(data).data;\r\n            data[0](data[1], ev);\r\n        }\r\n        return false;\r\n    },\r\n};\n\n// -----------------------------------------------------------------------------\r\n// Toggler node\r\n// -----------------------------------------------------------------------------\r\nclass VToggler {\r\n    constructor(key, child) {\r\n        this.key = key;\r\n        this.child = child;\r\n    }\r\n    mount(parent, afterNode) {\r\n        this.parentEl = parent;\r\n        this.child.mount(parent, afterNode);\r\n    }\r\n    moveBeforeDOMNode(node, parent) {\r\n        this.child.moveBeforeDOMNode(node, parent);\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        this.moveBeforeDOMNode((other && other.firstNode()) || afterNode);\r\n    }\r\n    patch(other, withBeforeRemove) {\r\n        if (this === other) {\r\n            return;\r\n        }\r\n        let child1 = this.child;\r\n        let child2 = other.child;\r\n        if (this.key === other.key) {\r\n            child1.patch(child2, withBeforeRemove);\r\n        }\r\n        else {\r\n            child2.mount(this.parentEl, child1.firstNode());\r\n            if (withBeforeRemove) {\r\n                child1.beforeRemove();\r\n            }\r\n            child1.remove();\r\n            this.child = child2;\r\n            this.key = other.key;\r\n        }\r\n    }\r\n    beforeRemove() {\r\n        this.child.beforeRemove();\r\n    }\r\n    remove() {\r\n        this.child.remove();\r\n    }\r\n    firstNode() {\r\n        return this.child.firstNode();\r\n    }\r\n    toString() {\r\n        return this.child.toString();\r\n    }\r\n}\r\nfunction toggler(key, child) {\r\n    return new VToggler(key, child);\r\n}\n\n// Custom error class that wraps error that happen in the owl lifecycle\r\nclass OwlError extends Error {\r\n}\n\nconst { setAttribute: elemSetAttribute, removeAttribute } = Element.prototype;\r\nconst tokenList = DOMTokenList.prototype;\r\nconst tokenListAdd = tokenList.add;\r\nconst tokenListRemove = tokenList.remove;\r\nconst isArray = Array.isArray;\r\nconst { split, trim } = String.prototype;\r\nconst wordRegexp = /\\s+/;\r\n/**\r\n * We regroup here all code related to updating attributes in a very loose sense:\r\n * attributes, properties and classs are all managed by the functions in this\r\n * file.\r\n */\r\nfunction setAttribute(key, value) {\r\n    switch (value) {\r\n        case false:\r\n        case undefined:\r\n            removeAttribute.call(this, key);\r\n            break;\r\n        case true:\r\n            elemSetAttribute.call(this, key, \"\");\r\n            break;\r\n        default:\r\n            elemSetAttribute.call(this, key, value);\r\n    }\r\n}\r\nfunction createAttrUpdater(attr) {\r\n    return function (value) {\r\n        setAttribute.call(this, attr, value);\r\n    };\r\n}\r\nfunction attrsSetter(attrs) {\r\n    if (isArray(attrs)) {\r\n        if (attrs[0] === \"class\") {\r\n            setClass.call(this, attrs[1]);\r\n        }\r\n        else {\r\n            setAttribute.call(this, attrs[0], attrs[1]);\r\n        }\r\n    }\r\n    else {\r\n        for (let k in attrs) {\r\n            if (k === \"class\") {\r\n                setClass.call(this, attrs[k]);\r\n            }\r\n            else {\r\n                setAttribute.call(this, k, attrs[k]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction attrsUpdater(attrs, oldAttrs) {\r\n    if (isArray(attrs)) {\r\n        const name = attrs[0];\r\n        const val = attrs[1];\r\n        if (name === oldAttrs[0]) {\r\n            if (val === oldAttrs[1]) {\r\n                return;\r\n            }\r\n            if (name === \"class\") {\r\n                updateClass.call(this, val, oldAttrs[1]);\r\n            }\r\n            else {\r\n                setAttribute.call(this, name, val);\r\n            }\r\n        }\r\n        else {\r\n            removeAttribute.call(this, oldAttrs[0]);\r\n            setAttribute.call(this, name, val);\r\n        }\r\n    }\r\n    else {\r\n        for (let k in oldAttrs) {\r\n            if (!(k in attrs)) {\r\n                if (k === \"class\") {\r\n                    updateClass.call(this, \"\", oldAttrs[k]);\r\n                }\r\n                else {\r\n                    removeAttribute.call(this, k);\r\n                }\r\n            }\r\n        }\r\n        for (let k in attrs) {\r\n            const val = attrs[k];\r\n            if (val !== oldAttrs[k]) {\r\n                if (k === \"class\") {\r\n                    updateClass.call(this, val, oldAttrs[k]);\r\n                }\r\n                else {\r\n                    setAttribute.call(this, k, val);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction toClassObj(expr) {\r\n    const result = {};\r\n    switch (typeof expr) {\r\n        case \"string\":\r\n            // we transform here a list of classes into an object:\r\n            //  'hey you' becomes {hey: true, you: true}\r\n            const str = trim.call(expr);\r\n            if (!str) {\r\n                return {};\r\n            }\r\n            let words = split.call(str, wordRegexp);\r\n            for (let i = 0, l = words.length; i < l; i++) {\r\n                result[words[i]] = true;\r\n            }\r\n            return result;\r\n        case \"object\":\r\n            // this is already an object but we may need to split keys:\r\n            // {'a': true, 'b c': true} should become {a: true, b: true, c: true}\r\n            for (let key in expr) {\r\n                const value = expr[key];\r\n                if (value) {\r\n                    key = trim.call(key);\r\n                    if (!key) {\r\n                        continue;\r\n                    }\r\n                    const words = split.call(key, wordRegexp);\r\n                    for (let word of words) {\r\n                        result[word] = value;\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        case \"undefined\":\r\n            return {};\r\n        case \"number\":\r\n            return { [expr]: true };\r\n        default:\r\n            return { [expr]: true };\r\n    }\r\n}\r\nfunction setClass(val) {\r\n    val = val === \"\" ? {} : toClassObj(val);\r\n    // add classes\r\n    const cl = this.classList;\r\n    for (let c in val) {\r\n        tokenListAdd.call(cl, c);\r\n    }\r\n}\r\nfunction updateClass(val, oldVal) {\r\n    oldVal = oldVal === \"\" ? {} : toClassObj(oldVal);\r\n    val = val === \"\" ? {} : toClassObj(val);\r\n    const cl = this.classList;\r\n    // remove classes\r\n    for (let c in oldVal) {\r\n        if (!(c in val)) {\r\n            tokenListRemove.call(cl, c);\r\n        }\r\n    }\r\n    // add classes\r\n    for (let c in val) {\r\n        if (!(c in oldVal)) {\r\n            tokenListAdd.call(cl, c);\r\n        }\r\n    }\r\n}\n\n/**\r\n * Creates a batched version of a callback so that all calls to it in the same\r\n * microtick will only call the original callback once.\r\n *\r\n * @param callback the callback to batch\r\n * @returns a batched version of the original callback\r\n */\r\nfunction batched(callback) {\r\n    let scheduled = false;\r\n    return async (...args) => {\r\n        if (!scheduled) {\r\n            scheduled = true;\r\n            await Promise.resolve();\r\n            scheduled = false;\r\n            callback(...args);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Determine whether the given element is contained in its ownerDocument:\r\n * either directly or with a shadow root in between.\r\n */\r\nfunction inOwnerDocument(el) {\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    if (el.ownerDocument.contains(el)) {\r\n        return true;\r\n    }\r\n    const rootNode = el.getRootNode();\r\n    return rootNode instanceof ShadowRoot && el.ownerDocument.contains(rootNode.host);\r\n}\r\n/**\r\n * Determine whether the given element is contained in a specific root documnet:\r\n * either directly or with a shadow root in between or in an iframe.\r\n */\r\nfunction isAttachedToDocument(element, documentElement) {\r\n    let current = element;\r\n    const shadowRoot = documentElement.defaultView.ShadowRoot;\r\n    while (current) {\r\n        if (current === documentElement) {\r\n            return true;\r\n        }\r\n        if (current.parentNode) {\r\n            current = current.parentNode;\r\n        }\r\n        else if (current instanceof shadowRoot && current.host) {\r\n            current = current.host;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction validateTarget(target) {\r\n    // Get the document and HTMLElement corresponding to the target to allow mounting in iframes\r\n    const document = target && target.ownerDocument;\r\n    if (document) {\r\n        if (!document.defaultView) {\r\n            throw new OwlError(\"Cannot mount a component: the target document is not attached to a window (defaultView is missing)\");\r\n        }\r\n        const HTMLElement = document.defaultView.HTMLElement;\r\n        if (target instanceof HTMLElement || target instanceof ShadowRoot) {\r\n            if (!isAttachedToDocument(target, document)) {\r\n                throw new OwlError(\"Cannot mount a component on a detached dom node\");\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    throw new OwlError(\"Cannot mount component: the target is not a valid DOM element\");\r\n}\r\nclass EventBus extends EventTarget {\r\n    trigger(name, payload) {\r\n        this.dispatchEvent(new CustomEvent(name, { detail: payload }));\r\n    }\r\n}\r\nfunction whenReady(fn) {\r\n    return new Promise(function (resolve) {\r\n        if (document.readyState !== \"loading\") {\r\n            resolve(true);\r\n        }\r\n        else {\r\n            document.addEventListener(\"DOMContentLoaded\", resolve, false);\r\n        }\r\n    }).then(fn || function () { });\r\n}\r\nasync function loadFile(url) {\r\n    const result = await fetch(url);\r\n    if (!result.ok) {\r\n        throw new OwlError(\"Error while fetching xml templates\");\r\n    }\r\n    return await result.text();\r\n}\r\n/*\r\n * This class just transports the fact that a string is safe\r\n * to be injected as HTML. Overriding a JS primitive is quite painful though\r\n * so we need to redfine toString and valueOf.\r\n */\r\nclass Markup extends String {\r\n}\r\nfunction htmlEscape(str) {\r\n    if (str instanceof Markup) {\r\n        return str;\r\n    }\r\n    if (str === undefined) {\r\n        return markup(\"\");\r\n    }\r\n    if (typeof str === \"number\") {\r\n        return markup(String(str));\r\n    }\r\n    [\r\n        [\"&\", \"&amp;\"],\r\n        [\"<\", \"&lt;\"],\r\n        [\">\", \"&gt;\"],\r\n        [\"'\", \"&#x27;\"],\r\n        ['\"', \"&quot;\"],\r\n        [\"`\", \"&#x60;\"],\r\n    ].forEach((pairs) => {\r\n        str = String(str).replace(new RegExp(pairs[0], \"g\"), pairs[1]);\r\n    });\r\n    return markup(str);\r\n}\r\nfunction markup(valueOrStrings, ...placeholders) {\r\n    if (!Array.isArray(valueOrStrings)) {\r\n        return new Markup(valueOrStrings);\r\n    }\r\n    const strings = valueOrStrings;\r\n    let acc = \"\";\r\n    let i = 0;\r\n    for (; i < placeholders.length; ++i) {\r\n        acc += strings[i] + htmlEscape(placeholders[i]);\r\n    }\r\n    acc += strings[i];\r\n    return new Markup(acc);\r\n}\n\nfunction createEventHandler(rawEvent) {\r\n    const eventName = rawEvent.split(\".\")[0];\r\n    const capture = rawEvent.includes(\".capture\");\r\n    if (rawEvent.includes(\".synthetic\")) {\r\n        return createSyntheticHandler(eventName, capture);\r\n    }\r\n    else {\r\n        return createElementHandler(eventName, capture);\r\n    }\r\n}\r\n// Native listener\r\nlet nextNativeEventId = 1;\r\nfunction createElementHandler(evName, capture = false) {\r\n    let eventKey = `__event__${evName}_${nextNativeEventId++}`;\r\n    if (capture) {\r\n        eventKey = `${eventKey}_capture`;\r\n    }\r\n    function listener(ev) {\r\n        const currentTarget = ev.currentTarget;\r\n        if (!currentTarget || !inOwnerDocument(currentTarget))\r\n            return;\r\n        const data = currentTarget[eventKey];\r\n        if (!data)\r\n            return;\r\n        config.mainEventHandler(data, ev, currentTarget);\r\n    }\r\n    function setup(data) {\r\n        this[eventKey] = data;\r\n        this.addEventListener(evName, listener, { capture });\r\n    }\r\n    function remove() {\r\n        delete this[eventKey];\r\n        this.removeEventListener(evName, listener, { capture });\r\n    }\r\n    function update(data) {\r\n        this[eventKey] = data;\r\n    }\r\n    return { setup, update, remove };\r\n}\r\n// Synthetic handler: a form of event delegation that allows placing only one\r\n// listener per event type.\r\nlet nextSyntheticEventId = 1;\r\nfunction createSyntheticHandler(evName, capture = false) {\r\n    let eventKey = `__event__synthetic_${evName}`;\r\n    if (capture) {\r\n        eventKey = `${eventKey}_capture`;\r\n    }\r\n    setupSyntheticEvent(evName, eventKey, capture);\r\n    const currentId = nextSyntheticEventId++;\r\n    function setup(data) {\r\n        const _data = this[eventKey] || {};\r\n        _data[currentId] = data;\r\n        this[eventKey] = _data;\r\n    }\r\n    function remove() {\r\n        delete this[eventKey];\r\n    }\r\n    return { setup, update: setup, remove };\r\n}\r\nfunction nativeToSyntheticEvent(eventKey, event) {\r\n    let dom = event.target;\r\n    while (dom !== null) {\r\n        const _data = dom[eventKey];\r\n        if (_data) {\r\n            for (const data of Object.values(_data)) {\r\n                const stopped = config.mainEventHandler(data, event, dom);\r\n                if (stopped)\r\n                    return;\r\n            }\r\n        }\r\n        dom = dom.parentNode;\r\n    }\r\n}\r\nconst CONFIGURED_SYNTHETIC_EVENTS = {};\r\nfunction setupSyntheticEvent(evName, eventKey, capture = false) {\r\n    if (CONFIGURED_SYNTHETIC_EVENTS[eventKey]) {\r\n        return;\r\n    }\r\n    document.addEventListener(evName, (event) => nativeToSyntheticEvent(eventKey, event), {\r\n        capture,\r\n    });\r\n    CONFIGURED_SYNTHETIC_EVENTS[eventKey] = true;\r\n}\n\nconst getDescriptor$3 = (o, p) => Object.getOwnPropertyDescriptor(o, p);\r\nconst nodeProto$4 = Node.prototype;\r\nconst nodeInsertBefore$3 = nodeProto$4.insertBefore;\r\nconst nodeSetTextContent$1 = getDescriptor$3(nodeProto$4, \"textContent\").set;\r\nconst nodeRemoveChild$3 = nodeProto$4.removeChild;\r\n// -----------------------------------------------------------------------------\r\n// Multi NODE\r\n// -----------------------------------------------------------------------------\r\nclass VMulti {\r\n    constructor(children) {\r\n        this.children = children;\r\n    }\r\n    mount(parent, afterNode) {\r\n        const children = this.children;\r\n        const l = children.length;\r\n        const anchors = new Array(l);\r\n        for (let i = 0; i < l; i++) {\r\n            let child = children[i];\r\n            if (child) {\r\n                child.mount(parent, afterNode);\r\n            }\r\n            else {\r\n                const childAnchor = document.createTextNode(\"\");\r\n                anchors[i] = childAnchor;\r\n                nodeInsertBefore$3.call(parent, childAnchor, afterNode);\r\n            }\r\n        }\r\n        this.anchors = anchors;\r\n        this.parentEl = parent;\r\n    }\r\n    moveBeforeDOMNode(node, parent = this.parentEl) {\r\n        this.parentEl = parent;\r\n        const children = this.children;\r\n        const anchors = this.anchors;\r\n        for (let i = 0, l = children.length; i < l; i++) {\r\n            let child = children[i];\r\n            if (child) {\r\n                child.moveBeforeDOMNode(node, parent);\r\n            }\r\n            else {\r\n                const anchor = anchors[i];\r\n                nodeInsertBefore$3.call(parent, anchor, node);\r\n            }\r\n        }\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        if (other) {\r\n            const next = other.children[0];\r\n            afterNode = (next ? next.firstNode() : other.anchors[0]) || null;\r\n        }\r\n        const children = this.children;\r\n        const parent = this.parentEl;\r\n        const anchors = this.anchors;\r\n        for (let i = 0, l = children.length; i < l; i++) {\r\n            let child = children[i];\r\n            if (child) {\r\n                child.moveBeforeVNode(null, afterNode);\r\n            }\r\n            else {\r\n                const anchor = anchors[i];\r\n                nodeInsertBefore$3.call(parent, anchor, afterNode);\r\n            }\r\n        }\r\n    }\r\n    patch(other, withBeforeRemove) {\r\n        if (this === other) {\r\n            return;\r\n        }\r\n        const children1 = this.children;\r\n        const children2 = other.children;\r\n        const anchors = this.anchors;\r\n        const parentEl = this.parentEl;\r\n        for (let i = 0, l = children1.length; i < l; i++) {\r\n            const vn1 = children1[i];\r\n            const vn2 = children2[i];\r\n            if (vn1) {\r\n                if (vn2) {\r\n                    vn1.patch(vn2, withBeforeRemove);\r\n                }\r\n                else {\r\n                    const afterNode = vn1.firstNode();\r\n                    const anchor = document.createTextNode(\"\");\r\n                    anchors[i] = anchor;\r\n                    nodeInsertBefore$3.call(parentEl, anchor, afterNode);\r\n                    if (withBeforeRemove) {\r\n                        vn1.beforeRemove();\r\n                    }\r\n                    vn1.remove();\r\n                    children1[i] = undefined;\r\n                }\r\n            }\r\n            else if (vn2) {\r\n                children1[i] = vn2;\r\n                const anchor = anchors[i];\r\n                vn2.mount(parentEl, anchor);\r\n                nodeRemoveChild$3.call(parentEl, anchor);\r\n            }\r\n        }\r\n    }\r\n    beforeRemove() {\r\n        const children = this.children;\r\n        for (let i = 0, l = children.length; i < l; i++) {\r\n            const child = children[i];\r\n            if (child) {\r\n                child.beforeRemove();\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        const parentEl = this.parentEl;\r\n        if (this.isOnlyChild) {\r\n            nodeSetTextContent$1.call(parentEl, \"\");\r\n        }\r\n        else {\r\n            const children = this.children;\r\n            const anchors = this.anchors;\r\n            for (let i = 0, l = children.length; i < l; i++) {\r\n                const child = children[i];\r\n                if (child) {\r\n                    child.remove();\r\n                }\r\n                else {\r\n                    nodeRemoveChild$3.call(parentEl, anchors[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    firstNode() {\r\n        const child = this.children[0];\r\n        return child ? child.firstNode() : this.anchors[0];\r\n    }\r\n    toString() {\r\n        return this.children.map((c) => (c ? c.toString() : \"\")).join(\"\");\r\n    }\r\n}\r\nfunction multi(children) {\r\n    return new VMulti(children);\r\n}\n\nconst getDescriptor$2 = (o, p) => Object.getOwnPropertyDescriptor(o, p);\r\nconst nodeProto$3 = Node.prototype;\r\nconst characterDataProto$1 = CharacterData.prototype;\r\nconst nodeInsertBefore$2 = nodeProto$3.insertBefore;\r\nconst characterDataSetData$1 = getDescriptor$2(characterDataProto$1, \"data\").set;\r\nconst nodeRemoveChild$2 = nodeProto$3.removeChild;\r\nclass VSimpleNode {\r\n    constructor(text) {\r\n        this.text = text;\r\n    }\r\n    mountNode(node, parent, afterNode) {\r\n        this.parentEl = parent;\r\n        nodeInsertBefore$2.call(parent, node, afterNode);\r\n        this.el = node;\r\n    }\r\n    moveBeforeDOMNode(node, parent = this.parentEl) {\r\n        this.parentEl = parent;\r\n        nodeInsertBefore$2.call(parent, this.el, node);\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        nodeInsertBefore$2.call(this.parentEl, this.el, other ? other.el : afterNode);\r\n    }\r\n    beforeRemove() { }\r\n    remove() {\r\n        nodeRemoveChild$2.call(this.parentEl, this.el);\r\n    }\r\n    firstNode() {\r\n        return this.el;\r\n    }\r\n    toString() {\r\n        return this.text;\r\n    }\r\n}\r\nclass VText$1 extends VSimpleNode {\r\n    mount(parent, afterNode) {\r\n        this.mountNode(document.createTextNode(toText(this.text)), parent, afterNode);\r\n    }\r\n    patch(other) {\r\n        const text2 = other.text;\r\n        if (this.text !== text2) {\r\n            characterDataSetData$1.call(this.el, toText(text2));\r\n            this.text = text2;\r\n        }\r\n    }\r\n}\r\nclass VComment extends VSimpleNode {\r\n    mount(parent, afterNode) {\r\n        this.mountNode(document.createComment(toText(this.text)), parent, afterNode);\r\n    }\r\n    patch() { }\r\n}\r\nfunction text(str) {\r\n    return new VText$1(str);\r\n}\r\nfunction comment(str) {\r\n    return new VComment(str);\r\n}\r\nfunction toText(value) {\r\n    switch (typeof value) {\r\n        case \"string\":\r\n            return value;\r\n        case \"number\":\r\n            return String(value);\r\n        case \"boolean\":\r\n            return value ? \"true\" : \"false\";\r\n        default:\r\n            return value || \"\";\r\n    }\r\n}\n\nconst getDescriptor$1 = (o, p) => Object.getOwnPropertyDescriptor(o, p);\r\nconst nodeProto$2 = Node.prototype;\r\nconst elementProto = Element.prototype;\r\nconst characterDataProto = CharacterData.prototype;\r\nconst characterDataSetData = getDescriptor$1(characterDataProto, \"data\").set;\r\nconst nodeGetFirstChild = getDescriptor$1(nodeProto$2, \"firstChild\").get;\r\nconst nodeGetNextSibling = getDescriptor$1(nodeProto$2, \"nextSibling\").get;\r\nconst NO_OP = () => { };\r\nfunction makePropSetter(name) {\r\n    return function setProp(value) {\r\n        // support 0, fallback to empty string for other falsy values\r\n        this[name] = value === 0 ? 0 : value ? value.valueOf() : \"\";\r\n    };\r\n}\r\nconst cache$1 = {};\r\n/**\r\n * Compiling blocks is a multi-step process:\r\n *\r\n * 1. build an IntermediateTree from the HTML element. This intermediate tree\r\n *    is a binary tree structure that encode dynamic info sub nodes, and the\r\n *    path required to reach them\r\n * 2. process the tree to build a block context, which is an object that aggregate\r\n *    all dynamic info in a list, and also, all ref indexes.\r\n * 3. process the context to build appropriate builder/setter functions\r\n * 4. make a dynamic block class, which will efficiently collect references and\r\n *    create/update dynamic locations/children\r\n *\r\n * @param str\r\n * @returns a new block type, that can build concrete blocks\r\n */\r\nfunction createBlock(str) {\r\n    if (str in cache$1) {\r\n        return cache$1[str];\r\n    }\r\n    // step 0: prepare html base element\r\n    const doc = new DOMParser().parseFromString(`<t>${str}</t>`, \"text/xml\");\r\n    const node = doc.firstChild.firstChild;\r\n    if (config.shouldNormalizeDom) {\r\n        normalizeNode(node);\r\n    }\r\n    // step 1: prepare intermediate tree\r\n    const tree = buildTree(node);\r\n    // step 2: prepare block context\r\n    const context = buildContext(tree);\r\n    // step 3: build the final block class\r\n    const template = tree.el;\r\n    const Block = buildBlock(template, context);\r\n    cache$1[str] = Block;\r\n    return Block;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Helper\r\n// -----------------------------------------------------------------------------\r\nfunction normalizeNode(node) {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n        if (!/\\S/.test(node.textContent)) {\r\n            node.remove();\r\n            return;\r\n        }\r\n    }\r\n    if (node.nodeType === Node.ELEMENT_NODE) {\r\n        if (node.tagName === \"pre\") {\r\n            return;\r\n        }\r\n    }\r\n    for (let i = node.childNodes.length - 1; i >= 0; --i) {\r\n        normalizeNode(node.childNodes.item(i));\r\n    }\r\n}\r\nfunction buildTree(node, parent = null, domParentTree = null) {\r\n    switch (node.nodeType) {\r\n        case Node.ELEMENT_NODE: {\r\n            // HTMLElement\r\n            let currentNS = domParentTree && domParentTree.currentNS;\r\n            const tagName = node.tagName;\r\n            let el = undefined;\r\n            const info = [];\r\n            if (tagName.startsWith(\"block-text-\")) {\r\n                const index = parseInt(tagName.slice(11), 10);\r\n                info.push({ type: \"text\", idx: index });\r\n                el = document.createTextNode(\"\");\r\n            }\r\n            if (tagName.startsWith(\"block-child-\")) {\r\n                if (!domParentTree.isRef) {\r\n                    addRef(domParentTree);\r\n                }\r\n                const index = parseInt(tagName.slice(12), 10);\r\n                info.push({ type: \"child\", idx: index });\r\n                el = document.createTextNode(\"\");\r\n            }\r\n            currentNS || (currentNS = node.namespaceURI);\r\n            if (!el) {\r\n                el = currentNS\r\n                    ? document.createElementNS(currentNS, tagName)\r\n                    : document.createElement(tagName);\r\n            }\r\n            if (el instanceof Element) {\r\n                if (!domParentTree) {\r\n                    // some html elements may have side effects when setting their attributes.\r\n                    // For example, setting the src attribute of an <img/> will trigger a\r\n                    // request to get the corresponding image. This is something that we\r\n                    // don't want at compile time. We avoid that by putting the content of\r\n                    // the block in a <template/> element\r\n                    const fragment = document.createElement(\"template\").content;\r\n                    fragment.appendChild(el);\r\n                }\r\n                const attrs = node.attributes;\r\n                for (let i = 0; i < attrs.length; i++) {\r\n                    const attrName = attrs[i].name;\r\n                    const attrValue = attrs[i].value;\r\n                    if (attrName.startsWith(\"block-handler-\")) {\r\n                        const idx = parseInt(attrName.slice(14), 10);\r\n                        info.push({\r\n                            type: \"handler\",\r\n                            idx,\r\n                            event: attrValue,\r\n                        });\r\n                    }\r\n                    else if (attrName.startsWith(\"block-attribute-\")) {\r\n                        const idx = parseInt(attrName.slice(16), 10);\r\n                        info.push({\r\n                            type: \"attribute\",\r\n                            idx,\r\n                            name: attrValue,\r\n                            tag: tagName,\r\n                        });\r\n                    }\r\n                    else if (attrName.startsWith(\"block-property-\")) {\r\n                        const idx = parseInt(attrName.slice(15), 10);\r\n                        info.push({\r\n                            type: \"property\",\r\n                            idx,\r\n                            name: attrValue,\r\n                            tag: tagName,\r\n                        });\r\n                    }\r\n                    else if (attrName === \"block-attributes\") {\r\n                        info.push({\r\n                            type: \"attributes\",\r\n                            idx: parseInt(attrValue, 10),\r\n                        });\r\n                    }\r\n                    else if (attrName === \"block-ref\") {\r\n                        info.push({\r\n                            type: \"ref\",\r\n                            idx: parseInt(attrValue, 10),\r\n                        });\r\n                    }\r\n                    else {\r\n                        el.setAttribute(attrs[i].name, attrValue);\r\n                    }\r\n                }\r\n            }\r\n            const tree = {\r\n                parent,\r\n                firstChild: null,\r\n                nextSibling: null,\r\n                el,\r\n                info,\r\n                refN: 0,\r\n                currentNS,\r\n            };\r\n            if (node.firstChild) {\r\n                const childNode = node.childNodes[0];\r\n                if (node.childNodes.length === 1 &&\r\n                    childNode.nodeType === Node.ELEMENT_NODE &&\r\n                    childNode.tagName.startsWith(\"block-child-\")) {\r\n                    const tagName = childNode.tagName;\r\n                    const index = parseInt(tagName.slice(12), 10);\r\n                    info.push({ idx: index, type: \"child\", isOnlyChild: true });\r\n                }\r\n                else {\r\n                    tree.firstChild = buildTree(node.firstChild, tree, tree);\r\n                    el.appendChild(tree.firstChild.el);\r\n                    let curNode = node.firstChild;\r\n                    let curTree = tree.firstChild;\r\n                    while ((curNode = curNode.nextSibling)) {\r\n                        curTree.nextSibling = buildTree(curNode, curTree, tree);\r\n                        el.appendChild(curTree.nextSibling.el);\r\n                        curTree = curTree.nextSibling;\r\n                    }\r\n                }\r\n            }\r\n            if (tree.info.length) {\r\n                addRef(tree);\r\n            }\r\n            return tree;\r\n        }\r\n        case Node.TEXT_NODE:\r\n        case Node.COMMENT_NODE: {\r\n            // text node or comment node\r\n            const el = node.nodeType === Node.TEXT_NODE\r\n                ? document.createTextNode(node.textContent)\r\n                : document.createComment(node.textContent);\r\n            return {\r\n                parent: parent,\r\n                firstChild: null,\r\n                nextSibling: null,\r\n                el,\r\n                info: [],\r\n                refN: 0,\r\n                currentNS: null,\r\n            };\r\n        }\r\n    }\r\n    throw new OwlError(\"boom\");\r\n}\r\nfunction addRef(tree) {\r\n    tree.isRef = true;\r\n    do {\r\n        tree.refN++;\r\n    } while ((tree = tree.parent));\r\n}\r\nfunction parentTree(tree) {\r\n    let parent = tree.parent;\r\n    while (parent && parent.nextSibling === tree) {\r\n        tree = parent;\r\n        parent = parent.parent;\r\n    }\r\n    return parent;\r\n}\r\nfunction buildContext(tree, ctx, fromIdx) {\r\n    if (!ctx) {\r\n        const children = new Array(tree.info.filter((v) => v.type === \"child\").length);\r\n        ctx = { collectors: [], locations: [], children, cbRefs: [], refN: tree.refN, refList: [] };\r\n        fromIdx = 0;\r\n    }\r\n    if (tree.refN) {\r\n        const initialIdx = fromIdx;\r\n        const isRef = tree.isRef;\r\n        const firstChild = tree.firstChild ? tree.firstChild.refN : 0;\r\n        const nextSibling = tree.nextSibling ? tree.nextSibling.refN : 0;\r\n        //node\r\n        if (isRef) {\r\n            for (let info of tree.info) {\r\n                info.refIdx = initialIdx;\r\n            }\r\n            tree.refIdx = initialIdx;\r\n            updateCtx(ctx, tree);\r\n            fromIdx++;\r\n        }\r\n        // right\r\n        if (nextSibling) {\r\n            const idx = fromIdx + firstChild;\r\n            ctx.collectors.push({ idx, prevIdx: initialIdx, getVal: nodeGetNextSibling });\r\n            buildContext(tree.nextSibling, ctx, idx);\r\n        }\r\n        // left\r\n        if (firstChild) {\r\n            ctx.collectors.push({ idx: fromIdx, prevIdx: initialIdx, getVal: nodeGetFirstChild });\r\n            buildContext(tree.firstChild, ctx, fromIdx);\r\n        }\r\n    }\r\n    return ctx;\r\n}\r\nfunction updateCtx(ctx, tree) {\r\n    for (let info of tree.info) {\r\n        switch (info.type) {\r\n            case \"text\":\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx: info.refIdx,\r\n                    setData: setText,\r\n                    updateData: setText,\r\n                });\r\n                break;\r\n            case \"child\":\r\n                if (info.isOnlyChild) {\r\n                    // tree is the parentnode here\r\n                    ctx.children[info.idx] = {\r\n                        parentRefIdx: info.refIdx,\r\n                        isOnlyChild: true,\r\n                    };\r\n                }\r\n                else {\r\n                    // tree is the anchor text node\r\n                    ctx.children[info.idx] = {\r\n                        parentRefIdx: parentTree(tree).refIdx,\r\n                        afterRefIdx: info.refIdx,\r\n                    };\r\n                }\r\n                break;\r\n            case \"property\": {\r\n                const refIdx = info.refIdx;\r\n                const setProp = makePropSetter(info.name);\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx,\r\n                    setData: setProp,\r\n                    updateData: setProp,\r\n                });\r\n                break;\r\n            }\r\n            case \"attribute\": {\r\n                const refIdx = info.refIdx;\r\n                let updater;\r\n                let setter;\r\n                if (info.name === \"class\") {\r\n                    setter = setClass;\r\n                    updater = updateClass;\r\n                }\r\n                else {\r\n                    setter = createAttrUpdater(info.name);\r\n                    updater = setter;\r\n                }\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx,\r\n                    setData: setter,\r\n                    updateData: updater,\r\n                });\r\n                break;\r\n            }\r\n            case \"attributes\":\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx: info.refIdx,\r\n                    setData: attrsSetter,\r\n                    updateData: attrsUpdater,\r\n                });\r\n                break;\r\n            case \"handler\": {\r\n                const { setup, update } = createEventHandler(info.event);\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx: info.refIdx,\r\n                    setData: setup,\r\n                    updateData: update,\r\n                });\r\n                break;\r\n            }\r\n            case \"ref\":\r\n                const index = ctx.cbRefs.push(info.idx) - 1;\r\n                ctx.locations.push({\r\n                    idx: info.idx,\r\n                    refIdx: info.refIdx,\r\n                    setData: makeRefSetter(index, ctx.refList),\r\n                    updateData: NO_OP,\r\n                });\r\n        }\r\n    }\r\n}\r\n// -----------------------------------------------------------------------------\r\n// building the concrete block class\r\n// -----------------------------------------------------------------------------\r\nfunction buildBlock(template, ctx) {\r\n    let B = createBlockClass(template, ctx);\r\n    if (ctx.cbRefs.length) {\r\n        const cbRefs = ctx.cbRefs;\r\n        const refList = ctx.refList;\r\n        let cbRefsNumber = cbRefs.length;\r\n        B = class extends B {\r\n            mount(parent, afterNode) {\r\n                refList.push(new Array(cbRefsNumber));\r\n                super.mount(parent, afterNode);\r\n                for (let cbRef of refList.pop()) {\r\n                    cbRef();\r\n                }\r\n            }\r\n            remove() {\r\n                super.remove();\r\n                for (let cbRef of cbRefs) {\r\n                    let fn = this.data[cbRef];\r\n                    fn(null);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    if (ctx.children.length) {\r\n        B = class extends B {\r\n            constructor(data, children) {\r\n                super(data);\r\n                this.children = children;\r\n            }\r\n        };\r\n        B.prototype.beforeRemove = VMulti.prototype.beforeRemove;\r\n        return (data, children = []) => new B(data, children);\r\n    }\r\n    return (data) => new B(data);\r\n}\r\nfunction createBlockClass(template, ctx) {\r\n    const { refN, collectors, children } = ctx;\r\n    const colN = collectors.length;\r\n    ctx.locations.sort((a, b) => a.idx - b.idx);\r\n    const locations = ctx.locations.map((loc) => ({\r\n        refIdx: loc.refIdx,\r\n        setData: loc.setData,\r\n        updateData: loc.updateData,\r\n    }));\r\n    const locN = locations.length;\r\n    const childN = children.length;\r\n    const childrenLocs = children;\r\n    const isDynamic = refN > 0;\r\n    // these values are defined here to make them faster to lookup in the class\r\n    // block scope\r\n    const nodeCloneNode = nodeProto$2.cloneNode;\r\n    const nodeInsertBefore = nodeProto$2.insertBefore;\r\n    const elementRemove = elementProto.remove;\r\n    class Block {\r\n        constructor(data) {\r\n            this.data = data;\r\n        }\r\n        beforeRemove() { }\r\n        remove() {\r\n            elementRemove.call(this.el);\r\n        }\r\n        firstNode() {\r\n            return this.el;\r\n        }\r\n        moveBeforeDOMNode(node, parent = this.parentEl) {\r\n            this.parentEl = parent;\r\n            nodeInsertBefore.call(parent, this.el, node);\r\n        }\r\n        moveBeforeVNode(other, afterNode) {\r\n            nodeInsertBefore.call(this.parentEl, this.el, other ? other.el : afterNode);\r\n        }\r\n        toString() {\r\n            const div = document.createElement(\"div\");\r\n            this.mount(div, null);\r\n            return div.innerHTML;\r\n        }\r\n        mount(parent, afterNode) {\r\n            const el = nodeCloneNode.call(template, true);\r\n            nodeInsertBefore.call(parent, el, afterNode);\r\n            this.el = el;\r\n            this.parentEl = parent;\r\n        }\r\n        patch(other, withBeforeRemove) { }\r\n    }\r\n    if (isDynamic) {\r\n        Block.prototype.mount = function mount(parent, afterNode) {\r\n            const el = nodeCloneNode.call(template, true);\r\n            // collecting references\r\n            const refs = new Array(refN);\r\n            this.refs = refs;\r\n            refs[0] = el;\r\n            for (let i = 0; i < colN; i++) {\r\n                const w = collectors[i];\r\n                refs[w.idx] = w.getVal.call(refs[w.prevIdx]);\r\n            }\r\n            // applying data to all update points\r\n            if (locN) {\r\n                const data = this.data;\r\n                for (let i = 0; i < locN; i++) {\r\n                    const loc = locations[i];\r\n                    loc.setData.call(refs[loc.refIdx], data[i]);\r\n                }\r\n            }\r\n            nodeInsertBefore.call(parent, el, afterNode);\r\n            // preparing all children\r\n            if (childN) {\r\n                const children = this.children;\r\n                for (let i = 0; i < childN; i++) {\r\n                    const child = children[i];\r\n                    if (child) {\r\n                        const loc = childrenLocs[i];\r\n                        const afterNode = loc.afterRefIdx ? refs[loc.afterRefIdx] : null;\r\n                        child.isOnlyChild = loc.isOnlyChild;\r\n                        child.mount(refs[loc.parentRefIdx], afterNode);\r\n                    }\r\n                }\r\n            }\r\n            this.el = el;\r\n            this.parentEl = parent;\r\n        };\r\n        Block.prototype.patch = function patch(other, withBeforeRemove) {\r\n            if (this === other) {\r\n                return;\r\n            }\r\n            const refs = this.refs;\r\n            // update texts/attributes/\r\n            if (locN) {\r\n                const data1 = this.data;\r\n                const data2 = other.data;\r\n                for (let i = 0; i < locN; i++) {\r\n                    const val1 = data1[i];\r\n                    const val2 = data2[i];\r\n                    if (val1 !== val2) {\r\n                        const loc = locations[i];\r\n                        loc.updateData.call(refs[loc.refIdx], val2, val1);\r\n                    }\r\n                }\r\n                this.data = data2;\r\n            }\r\n            // update children\r\n            if (childN) {\r\n                let children1 = this.children;\r\n                const children2 = other.children;\r\n                for (let i = 0; i < childN; i++) {\r\n                    const child1 = children1[i];\r\n                    const child2 = children2[i];\r\n                    if (child1) {\r\n                        if (child2) {\r\n                            child1.patch(child2, withBeforeRemove);\r\n                        }\r\n                        else {\r\n                            if (withBeforeRemove) {\r\n                                child1.beforeRemove();\r\n                            }\r\n                            child1.remove();\r\n                            children1[i] = undefined;\r\n                        }\r\n                    }\r\n                    else if (child2) {\r\n                        const loc = childrenLocs[i];\r\n                        const afterNode = loc.afterRefIdx ? refs[loc.afterRefIdx] : null;\r\n                        child2.mount(refs[loc.parentRefIdx], afterNode);\r\n                        children1[i] = child2;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return Block;\r\n}\r\nfunction setText(value) {\r\n    characterDataSetData.call(this, toText(value));\r\n}\r\nfunction makeRefSetter(index, refs) {\r\n    return function setRef(fn) {\r\n        refs[refs.length - 1][index] = () => fn(this);\r\n    };\r\n}\n\nconst getDescriptor = (o, p) => Object.getOwnPropertyDescriptor(o, p);\r\nconst nodeProto$1 = Node.prototype;\r\nconst nodeInsertBefore$1 = nodeProto$1.insertBefore;\r\nconst nodeAppendChild = nodeProto$1.appendChild;\r\nconst nodeRemoveChild$1 = nodeProto$1.removeChild;\r\nconst nodeSetTextContent = getDescriptor(nodeProto$1, \"textContent\").set;\r\n// -----------------------------------------------------------------------------\r\n// List Node\r\n// -----------------------------------------------------------------------------\r\nclass VList {\r\n    constructor(children) {\r\n        this.children = children;\r\n    }\r\n    mount(parent, afterNode) {\r\n        const children = this.children;\r\n        const _anchor = document.createTextNode(\"\");\r\n        this.anchor = _anchor;\r\n        nodeInsertBefore$1.call(parent, _anchor, afterNode);\r\n        const l = children.length;\r\n        if (l) {\r\n            const mount = children[0].mount;\r\n            for (let i = 0; i < l; i++) {\r\n                mount.call(children[i], parent, _anchor);\r\n            }\r\n        }\r\n        this.parentEl = parent;\r\n    }\r\n    moveBeforeDOMNode(node, parent = this.parentEl) {\r\n        this.parentEl = parent;\r\n        const children = this.children;\r\n        for (let i = 0, l = children.length; i < l; i++) {\r\n            children[i].moveBeforeDOMNode(node, parent);\r\n        }\r\n        parent.insertBefore(this.anchor, node);\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        if (other) {\r\n            const next = other.children[0];\r\n            afterNode = (next ? next.firstNode() : other.anchor) || null;\r\n        }\r\n        const children = this.children;\r\n        for (let i = 0, l = children.length; i < l; i++) {\r\n            children[i].moveBeforeVNode(null, afterNode);\r\n        }\r\n        this.parentEl.insertBefore(this.anchor, afterNode);\r\n    }\r\n    patch(other, withBeforeRemove) {\r\n        if (this === other) {\r\n            return;\r\n        }\r\n        const ch1 = this.children;\r\n        const ch2 = other.children;\r\n        if (ch2.length === 0 && ch1.length === 0) {\r\n            return;\r\n        }\r\n        this.children = ch2;\r\n        const proto = ch2[0] || ch1[0];\r\n        const { mount: cMount, patch: cPatch, remove: cRemove, beforeRemove, moveBeforeVNode: cMoveBefore, firstNode: cFirstNode, } = proto;\r\n        const _anchor = this.anchor;\r\n        const isOnlyChild = this.isOnlyChild;\r\n        const parent = this.parentEl;\r\n        // fast path: no new child => only remove\r\n        if (ch2.length === 0 && isOnlyChild) {\r\n            if (withBeforeRemove) {\r\n                for (let i = 0, l = ch1.length; i < l; i++) {\r\n                    beforeRemove.call(ch1[i]);\r\n                }\r\n            }\r\n            nodeSetTextContent.call(parent, \"\");\r\n            nodeAppendChild.call(parent, _anchor);\r\n            return;\r\n        }\r\n        let startIdx1 = 0;\r\n        let startIdx2 = 0;\r\n        let startVn1 = ch1[0];\r\n        let startVn2 = ch2[0];\r\n        let endIdx1 = ch1.length - 1;\r\n        let endIdx2 = ch2.length - 1;\r\n        let endVn1 = ch1[endIdx1];\r\n        let endVn2 = ch2[endIdx2];\r\n        let mapping = undefined;\r\n        while (startIdx1 <= endIdx1 && startIdx2 <= endIdx2) {\r\n            // -------------------------------------------------------------------\r\n            if (startVn1 === null) {\r\n                startVn1 = ch1[++startIdx1];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            if (endVn1 === null) {\r\n                endVn1 = ch1[--endIdx1];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            let startKey1 = startVn1.key;\r\n            let startKey2 = startVn2.key;\r\n            if (startKey1 === startKey2) {\r\n                cPatch.call(startVn1, startVn2, withBeforeRemove);\r\n                ch2[startIdx2] = startVn1;\r\n                startVn1 = ch1[++startIdx1];\r\n                startVn2 = ch2[++startIdx2];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            let endKey1 = endVn1.key;\r\n            let endKey2 = endVn2.key;\r\n            if (endKey1 === endKey2) {\r\n                cPatch.call(endVn1, endVn2, withBeforeRemove);\r\n                ch2[endIdx2] = endVn1;\r\n                endVn1 = ch1[--endIdx1];\r\n                endVn2 = ch2[--endIdx2];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            if (startKey1 === endKey2) {\r\n                // bnode moved right\r\n                cPatch.call(startVn1, endVn2, withBeforeRemove);\r\n                ch2[endIdx2] = startVn1;\r\n                const nextChild = ch2[endIdx2 + 1];\r\n                cMoveBefore.call(startVn1, nextChild, _anchor);\r\n                startVn1 = ch1[++startIdx1];\r\n                endVn2 = ch2[--endIdx2];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            if (endKey1 === startKey2) {\r\n                // bnode moved left\r\n                cPatch.call(endVn1, startVn2, withBeforeRemove);\r\n                ch2[startIdx2] = endVn1;\r\n                const nextChild = ch1[startIdx1];\r\n                cMoveBefore.call(endVn1, nextChild, _anchor);\r\n                endVn1 = ch1[--endIdx1];\r\n                startVn2 = ch2[++startIdx2];\r\n                continue;\r\n            }\r\n            // -------------------------------------------------------------------\r\n            mapping = mapping || createMapping(ch1, startIdx1, endIdx1);\r\n            let idxInOld = mapping[startKey2];\r\n            if (idxInOld === undefined) {\r\n                cMount.call(startVn2, parent, cFirstNode.call(startVn1) || null);\r\n            }\r\n            else {\r\n                const elmToMove = ch1[idxInOld];\r\n                cMoveBefore.call(elmToMove, startVn1, null);\r\n                cPatch.call(elmToMove, startVn2, withBeforeRemove);\r\n                ch2[startIdx2] = elmToMove;\r\n                ch1[idxInOld] = null;\r\n            }\r\n            startVn2 = ch2[++startIdx2];\r\n        }\r\n        // ---------------------------------------------------------------------\r\n        if (startIdx1 <= endIdx1 || startIdx2 <= endIdx2) {\r\n            if (startIdx1 > endIdx1) {\r\n                const nextChild = ch2[endIdx2 + 1];\r\n                const anchor = nextChild ? cFirstNode.call(nextChild) || null : _anchor;\r\n                for (let i = startIdx2; i <= endIdx2; i++) {\r\n                    cMount.call(ch2[i], parent, anchor);\r\n                }\r\n            }\r\n            else {\r\n                for (let i = startIdx1; i <= endIdx1; i++) {\r\n                    let ch = ch1[i];\r\n                    if (ch) {\r\n                        if (withBeforeRemove) {\r\n                            beforeRemove.call(ch);\r\n                        }\r\n                        cRemove.call(ch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    beforeRemove() {\r\n        const children = this.children;\r\n        const l = children.length;\r\n        if (l) {\r\n            const beforeRemove = children[0].beforeRemove;\r\n            for (let i = 0; i < l; i++) {\r\n                beforeRemove.call(children[i]);\r\n            }\r\n        }\r\n    }\r\n    remove() {\r\n        const { parentEl, anchor } = this;\r\n        if (this.isOnlyChild) {\r\n            nodeSetTextContent.call(parentEl, \"\");\r\n        }\r\n        else {\r\n            const children = this.children;\r\n            const l = children.length;\r\n            if (l) {\r\n                const remove = children[0].remove;\r\n                for (let i = 0; i < l; i++) {\r\n                    remove.call(children[i]);\r\n                }\r\n            }\r\n            nodeRemoveChild$1.call(parentEl, anchor);\r\n        }\r\n    }\r\n    firstNode() {\r\n        const child = this.children[0];\r\n        return child ? child.firstNode() : undefined;\r\n    }\r\n    toString() {\r\n        return this.children.map((c) => c.toString()).join(\"\");\r\n    }\r\n}\r\nfunction list(children) {\r\n    return new VList(children);\r\n}\r\nfunction createMapping(ch1, startIdx1, endIdx2) {\r\n    let mapping = {};\r\n    for (let i = startIdx1; i <= endIdx2; i++) {\r\n        mapping[ch1[i].key] = i;\r\n    }\r\n    return mapping;\r\n}\n\nconst nodeProto = Node.prototype;\r\nconst nodeInsertBefore = nodeProto.insertBefore;\r\nconst nodeRemoveChild = nodeProto.removeChild;\r\nclass VHtml {\r\n    constructor(html) {\r\n        this.content = [];\r\n        this.html = html;\r\n    }\r\n    mount(parent, afterNode) {\r\n        this.parentEl = parent;\r\n        const template = document.createElement(\"template\");\r\n        template.innerHTML = this.html;\r\n        this.content = [...template.content.childNodes];\r\n        for (let elem of this.content) {\r\n            nodeInsertBefore.call(parent, elem, afterNode);\r\n        }\r\n        if (!this.content.length) {\r\n            const textNode = document.createTextNode(\"\");\r\n            this.content.push(textNode);\r\n            nodeInsertBefore.call(parent, textNode, afterNode);\r\n        }\r\n    }\r\n    moveBeforeDOMNode(node, parent = this.parentEl) {\r\n        this.parentEl = parent;\r\n        for (let elem of this.content) {\r\n            nodeInsertBefore.call(parent, elem, node);\r\n        }\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        const target = other ? other.content[0] : afterNode;\r\n        this.moveBeforeDOMNode(target);\r\n    }\r\n    patch(other) {\r\n        if (this === other) {\r\n            return;\r\n        }\r\n        const html2 = other.html;\r\n        if (this.html !== html2) {\r\n            const parent = this.parentEl;\r\n            // insert new html in front of current\r\n            const afterNode = this.content[0];\r\n            const template = document.createElement(\"template\");\r\n            template.innerHTML = html2;\r\n            const content = [...template.content.childNodes];\r\n            for (let elem of content) {\r\n                nodeInsertBefore.call(parent, elem, afterNode);\r\n            }\r\n            if (!content.length) {\r\n                const textNode = document.createTextNode(\"\");\r\n                content.push(textNode);\r\n                nodeInsertBefore.call(parent, textNode, afterNode);\r\n            }\r\n            // remove current content\r\n            this.remove();\r\n            this.content = content;\r\n            this.html = other.html;\r\n        }\r\n    }\r\n    beforeRemove() { }\r\n    remove() {\r\n        const parent = this.parentEl;\r\n        for (let elem of this.content) {\r\n            nodeRemoveChild.call(parent, elem);\r\n        }\r\n    }\r\n    firstNode() {\r\n        return this.content[0];\r\n    }\r\n    toString() {\r\n        return this.html;\r\n    }\r\n}\r\nfunction html(str) {\r\n    return new VHtml(str);\r\n}\n\nfunction createCatcher(eventsSpec) {\r\n    const n = Object.keys(eventsSpec).length;\r\n    class VCatcher {\r\n        constructor(child, handlers) {\r\n            this.handlerFns = [];\r\n            this.afterNode = null;\r\n            this.child = child;\r\n            this.handlerData = handlers;\r\n        }\r\n        mount(parent, afterNode) {\r\n            this.parentEl = parent;\r\n            this.child.mount(parent, afterNode);\r\n            this.afterNode = document.createTextNode(\"\");\r\n            parent.insertBefore(this.afterNode, afterNode);\r\n            this.wrapHandlerData();\r\n            for (let name in eventsSpec) {\r\n                const index = eventsSpec[name];\r\n                const handler = createEventHandler(name);\r\n                this.handlerFns[index] = handler;\r\n                handler.setup.call(parent, this.handlerData[index]);\r\n            }\r\n        }\r\n        wrapHandlerData() {\r\n            for (let i = 0; i < n; i++) {\r\n                let handler = this.handlerData[i];\r\n                // handler = [...mods, fn, comp], so we need to replace second to last elem\r\n                let idx = handler.length - 2;\r\n                let origFn = handler[idx];\r\n                const self = this;\r\n                handler[idx] = function (ev) {\r\n                    const target = ev.target;\r\n                    let currentNode = self.child.firstNode();\r\n                    const afterNode = self.afterNode;\r\n                    while (currentNode && currentNode !== afterNode) {\r\n                        if (currentNode.contains(target)) {\r\n                            return origFn.call(this, ev);\r\n                        }\r\n                        currentNode = currentNode.nextSibling;\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        moveBeforeDOMNode(node, parent = this.parentEl) {\r\n            this.parentEl = parent;\r\n            this.child.moveBeforeDOMNode(node, parent);\r\n            parent.insertBefore(this.afterNode, node);\r\n        }\r\n        moveBeforeVNode(other, afterNode) {\r\n            if (other) {\r\n                // check this with @ged-odoo for use in foreach\r\n                afterNode = other.firstNode() || afterNode;\r\n            }\r\n            this.child.moveBeforeVNode(other ? other.child : null, afterNode);\r\n            this.parentEl.insertBefore(this.afterNode, afterNode);\r\n        }\r\n        patch(other, withBeforeRemove) {\r\n            if (this === other) {\r\n                return;\r\n            }\r\n            this.handlerData = other.handlerData;\r\n            this.wrapHandlerData();\r\n            for (let i = 0; i < n; i++) {\r\n                this.handlerFns[i].update.call(this.parentEl, this.handlerData[i]);\r\n            }\r\n            this.child.patch(other.child, withBeforeRemove);\r\n        }\r\n        beforeRemove() {\r\n            this.child.beforeRemove();\r\n        }\r\n        remove() {\r\n            for (let i = 0; i < n; i++) {\r\n                this.handlerFns[i].remove.call(this.parentEl);\r\n            }\r\n            this.child.remove();\r\n            this.afterNode.remove();\r\n        }\r\n        firstNode() {\r\n            return this.child.firstNode();\r\n        }\r\n        toString() {\r\n            return this.child.toString();\r\n        }\r\n    }\r\n    return function (child, handlers) {\r\n        return new VCatcher(child, handlers);\r\n    };\r\n}\n\nfunction mount$1(vnode, fixture, afterNode = null) {\r\n    vnode.mount(fixture, afterNode);\r\n}\r\nfunction patch(vnode1, vnode2, withBeforeRemove = false) {\r\n    vnode1.patch(vnode2, withBeforeRemove);\r\n}\r\nfunction remove(vnode, withBeforeRemove = false) {\r\n    if (withBeforeRemove) {\r\n        vnode.beforeRemove();\r\n    }\r\n    vnode.remove();\r\n}\n\n// Maps fibers to thrown errors\r\nconst fibersInError = new WeakMap();\r\nconst nodeErrorHandlers = new WeakMap();\r\nfunction _handleError(node, error) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const fiber = node.fiber;\r\n    if (fiber) {\r\n        fibersInError.set(fiber, error);\r\n    }\r\n    const errorHandlers = nodeErrorHandlers.get(node);\r\n    if (errorHandlers) {\r\n        let handled = false;\r\n        // execute in the opposite order\r\n        for (let i = errorHandlers.length - 1; i >= 0; i--) {\r\n            try {\r\n                errorHandlers[i](error);\r\n                handled = true;\r\n                break;\r\n            }\r\n            catch (e) {\r\n                error = e;\r\n            }\r\n        }\r\n        if (handled) {\r\n            return true;\r\n        }\r\n    }\r\n    return _handleError(node.parent, error);\r\n}\r\nfunction handleError(params) {\r\n    let { error } = params;\r\n    // Wrap error if it wasn't wrapped by wrapError (ie when not in dev mode)\r\n    if (!(error instanceof OwlError)) {\r\n        error = Object.assign(new OwlError(`An error occured in the owl lifecycle (see this Error's \"cause\" property)`), { cause: error });\r\n    }\r\n    const node = \"node\" in params ? params.node : params.fiber.node;\r\n    const fiber = \"fiber\" in params ? params.fiber : node.fiber;\r\n    if (fiber) {\r\n        // resets the fibers on components if possible. This is important so that\r\n        // new renderings can be properly included in the initial one, if any.\r\n        let current = fiber;\r\n        do {\r\n            current.node.fiber = current;\r\n            current = current.parent;\r\n        } while (current);\r\n        fibersInError.set(fiber.root, error);\r\n    }\r\n    const handled = _handleError(node, error);\r\n    if (!handled) {\r\n        console.warn(`[Owl] Unhandled error. Destroying the root component`);\r\n        try {\r\n            node.app.destroy();\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n        throw error;\r\n    }\r\n}\n\nfunction makeChildFiber(node, parent) {\r\n    let current = node.fiber;\r\n    if (current) {\r\n        cancelFibers(current.children);\r\n        current.root = null;\r\n    }\r\n    return new Fiber(node, parent);\r\n}\r\nfunction makeRootFiber(node) {\r\n    let current = node.fiber;\r\n    if (current) {\r\n        let root = current.root;\r\n        // lock root fiber because canceling children fibers may destroy components,\r\n        // which means any arbitrary code can be run in onWillDestroy, which may\r\n        // trigger new renderings\r\n        root.locked = true;\r\n        root.setCounter(root.counter + 1 - cancelFibers(current.children));\r\n        root.locked = false;\r\n        current.children = [];\r\n        current.childrenMap = {};\r\n        current.bdom = null;\r\n        if (fibersInError.has(current)) {\r\n            fibersInError.delete(current);\r\n            fibersInError.delete(root);\r\n            current.appliedToDom = false;\r\n            if (current instanceof RootFiber) {\r\n                // it is possible that this fiber is a fiber that crashed while being\r\n                // mounted, so the mounted list is possibly corrupted. We restore it to\r\n                // its normal initial state (which is empty list or a list with a mount\r\n                // fiber.\r\n                current.mounted = current instanceof MountFiber ? [current] : [];\r\n            }\r\n        }\r\n        return current;\r\n    }\r\n    const fiber = new RootFiber(node, null);\r\n    if (node.willPatch.length) {\r\n        fiber.willPatch.push(fiber);\r\n    }\r\n    if (node.patched.length) {\r\n        fiber.patched.push(fiber);\r\n    }\r\n    return fiber;\r\n}\r\nfunction throwOnRender() {\r\n    throw new OwlError(\"Attempted to render cancelled fiber\");\r\n}\r\n/**\r\n * @returns number of not-yet rendered fibers cancelled\r\n */\r\nfunction cancelFibers(fibers) {\r\n    let result = 0;\r\n    for (let fiber of fibers) {\r\n        let node = fiber.node;\r\n        fiber.render = throwOnRender;\r\n        if (node.status === 0 /* NEW */) {\r\n            node.cancel();\r\n        }\r\n        node.fiber = null;\r\n        if (fiber.bdom) {\r\n            // if fiber has been rendered, this means that the component props have\r\n            // been updated. however, this fiber will not be patched to the dom, so\r\n            // it could happen that the next render compare the current props with\r\n            // the same props, and skip the render completely. With the next line,\r\n            // we kindly request the component code to force a render, so it works as\r\n            // expected.\r\n            node.forceNextRender = true;\r\n        }\r\n        else {\r\n            result++;\r\n        }\r\n        result += cancelFibers(fiber.children);\r\n    }\r\n    return result;\r\n}\r\nclass Fiber {\r\n    constructor(node, parent) {\r\n        this.bdom = null;\r\n        this.children = [];\r\n        this.appliedToDom = false;\r\n        this.deep = false;\r\n        this.childrenMap = {};\r\n        this.node = node;\r\n        this.parent = parent;\r\n        if (parent) {\r\n            this.deep = parent.deep;\r\n            const root = parent.root;\r\n            root.setCounter(root.counter + 1);\r\n            this.root = root;\r\n            parent.children.push(this);\r\n        }\r\n        else {\r\n            this.root = this;\r\n        }\r\n    }\r\n    render() {\r\n        // if some parent has a fiber => register in followup\r\n        let prev = this.root.node;\r\n        let scheduler = prev.app.scheduler;\r\n        let current = prev.parent;\r\n        while (current) {\r\n            if (current.fiber) {\r\n                let root = current.fiber.root;\r\n                if (root.counter === 0 && prev.parentKey in current.fiber.childrenMap) {\r\n                    current = root.node;\r\n                }\r\n                else {\r\n                    scheduler.delayedRenders.push(this);\r\n                    return;\r\n                }\r\n            }\r\n            prev = current;\r\n            current = current.parent;\r\n        }\r\n        // there are no current rendering from above => we can render\r\n        this._render();\r\n    }\r\n    _render() {\r\n        const node = this.node;\r\n        const root = this.root;\r\n        if (root) {\r\n            try {\r\n                this.bdom = true;\r\n                this.bdom = node.renderFn();\r\n            }\r\n            catch (e) {\r\n                node.app.handleError({ node, error: e });\r\n            }\r\n            root.setCounter(root.counter - 1);\r\n        }\r\n    }\r\n}\r\nclass RootFiber extends Fiber {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.counter = 1;\r\n        // only add stuff in this if they have registered some hooks\r\n        this.willPatch = [];\r\n        this.patched = [];\r\n        this.mounted = [];\r\n        // A fiber is typically locked when it is completing and the patch has not, or is being applied.\r\n        // i.e.: render triggered in onWillUnmount or in willPatch will be delayed\r\n        this.locked = false;\r\n    }\r\n    complete() {\r\n        const node = this.node;\r\n        this.locked = true;\r\n        let current = undefined;\r\n        let mountedFibers = this.mounted;\r\n        try {\r\n            // Step 1: calling all willPatch lifecycle hooks\r\n            for (current of this.willPatch) {\r\n                // because of the asynchronous nature of the rendering, some parts of the\r\n                // UI may have been rendered, then deleted in a followup rendering, and we\r\n                // do not want to call onWillPatch in that case.\r\n                let node = current.node;\r\n                if (node.fiber === current) {\r\n                    const component = node.component;\r\n                    for (let cb of node.willPatch) {\r\n                        cb.call(component);\r\n                    }\r\n                }\r\n            }\r\n            current = undefined;\r\n            // Step 2: patching the dom\r\n            node._patch();\r\n            this.locked = false;\r\n            // Step 4: calling all mounted lifecycle hooks\r\n            while ((current = mountedFibers.pop())) {\r\n                current = current;\r\n                if (current.appliedToDom) {\r\n                    for (let cb of current.node.mounted) {\r\n                        cb();\r\n                    }\r\n                }\r\n            }\r\n            // Step 5: calling all patched hooks\r\n            let patchedFibers = this.patched;\r\n            while ((current = patchedFibers.pop())) {\r\n                current = current;\r\n                if (current.appliedToDom) {\r\n                    for (let cb of current.node.patched) {\r\n                        cb();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // if mountedFibers is not empty, this means that a crash occured while\r\n            // calling the mounted hooks of some component. So, there may still be\r\n            // some component that have been mounted, but for which the mounted hooks\r\n            // have not been called. Here, we remove the willUnmount hooks for these\r\n            // specific component to prevent a worse situation (willUnmount being\r\n            // called even though mounted has not been called)\r\n            for (let fiber of mountedFibers) {\r\n                fiber.node.willUnmount = [];\r\n            }\r\n            this.locked = false;\r\n            node.app.handleError({ fiber: current || this, error: e });\r\n        }\r\n    }\r\n    setCounter(newValue) {\r\n        this.counter = newValue;\r\n        if (newValue === 0) {\r\n            this.node.app.scheduler.flush();\r\n        }\r\n    }\r\n}\r\nclass MountFiber extends RootFiber {\r\n    constructor(node, target, options = {}) {\r\n        super(node, null);\r\n        this.target = target;\r\n        this.position = options.position || \"last-child\";\r\n    }\r\n    complete() {\r\n        let current = this;\r\n        try {\r\n            const node = this.node;\r\n            node.children = this.childrenMap;\r\n            node.app.constructor.validateTarget(this.target);\r\n            if (node.bdom) {\r\n                // this is a complicated situation: if we mount a fiber with an existing\r\n                // bdom, this means that this same fiber was already completed, mounted,\r\n                // but a crash occurred in some mounted hook. Then, it was handled and\r\n                // the new rendering is being applied.\r\n                node.updateDom();\r\n            }\r\n            else {\r\n                node.bdom = this.bdom;\r\n                if (this.position === \"last-child\" || this.target.childNodes.length === 0) {\r\n                    mount$1(node.bdom, this.target);\r\n                }\r\n                else {\r\n                    const firstChild = this.target.childNodes[0];\r\n                    mount$1(node.bdom, this.target, firstChild);\r\n                }\r\n            }\r\n            // unregistering the fiber before mounted since it can do another render\r\n            // and that the current rendering is obviously completed\r\n            node.fiber = null;\r\n            node.status = 1 /* MOUNTED */;\r\n            this.appliedToDom = true;\r\n            let mountedFibers = this.mounted;\r\n            while ((current = mountedFibers.pop())) {\r\n                if (current.appliedToDom) {\r\n                    for (let cb of current.node.mounted) {\r\n                        cb();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            this.node.app.handleError({ fiber: current, error: e });\r\n        }\r\n    }\r\n}\n\n// Special key to subscribe to, to be notified of key creation/deletion\r\nconst KEYCHANGES = Symbol(\"Key changes\");\r\n// Used to specify the absence of a callback, can be used as WeakMap key but\r\n// should only be used as a sentinel value and never called.\r\nconst NO_CALLBACK = () => {\r\n    throw new Error(\"Called NO_CALLBACK. Owl is broken, please report this to the maintainers.\");\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst objectHasOwnProperty = Object.prototype.hasOwnProperty;\r\n// Use arrays because Array.includes is faster than Set.has for small arrays\r\nconst SUPPORTED_RAW_TYPES = [\"Object\", \"Array\", \"Set\", \"Map\", \"WeakMap\"];\r\nconst COLLECTION_RAW_TYPES = [\"Set\", \"Map\", \"WeakMap\"];\r\n/**\r\n * extract \"RawType\" from strings like \"[object RawType]\" => this lets us ignore\r\n * many native objects such as Promise (whose toString is [object Promise])\r\n * or Date ([object Date]), while also supporting collections without using\r\n * instanceof in a loop\r\n *\r\n * @param obj the object to check\r\n * @returns the raw type of the object\r\n */\r\nfunction rawType(obj) {\r\n    return objectToString.call(toRaw(obj)).slice(8, -1);\r\n}\r\n/**\r\n * Checks whether a given value can be made into a reactive object.\r\n *\r\n * @param value the value to check\r\n * @returns whether the value can be made reactive\r\n */\r\nfunction canBeMadeReactive(value) {\r\n    if (typeof value !== \"object\") {\r\n        return false;\r\n    }\r\n    return SUPPORTED_RAW_TYPES.includes(rawType(value));\r\n}\r\n/**\r\n * Creates a reactive from the given object/callback if possible and returns it,\r\n * returns the original object otherwise.\r\n *\r\n * @param value the value make reactive\r\n * @returns a reactive for the given object when possible, the original otherwise\r\n */\r\nfunction possiblyReactive(val, cb) {\r\n    return canBeMadeReactive(val) ? reactive(val, cb) : val;\r\n}\r\nconst skipped = new WeakSet();\r\n/**\r\n * Mark an object or array so that it is ignored by the reactivity system\r\n *\r\n * @param value the value to mark\r\n * @returns the object itself\r\n */\r\nfunction markRaw(value) {\r\n    skipped.add(value);\r\n    return value;\r\n}\r\n/**\r\n * Given a reactive objet, return the raw (non reactive) underlying object\r\n *\r\n * @param value a reactive value\r\n * @returns the underlying value\r\n */\r\nfunction toRaw(value) {\r\n    return targets.has(value) ? targets.get(value) : value;\r\n}\r\nconst targetToKeysToCallbacks = new WeakMap();\r\n/**\r\n * Observes a given key on a target with an callback. The callback will be\r\n * called when the given key changes on the target.\r\n *\r\n * @param target the target whose key should be observed\r\n * @param key the key to observe (or Symbol(KEYCHANGES) for key creation\r\n *  or deletion)\r\n * @param callback the function to call when the key changes\r\n */\r\nfunction observeTargetKey(target, key, callback) {\r\n    if (callback === NO_CALLBACK) {\r\n        return;\r\n    }\r\n    if (!targetToKeysToCallbacks.get(target)) {\r\n        targetToKeysToCallbacks.set(target, new Map());\r\n    }\r\n    const keyToCallbacks = targetToKeysToCallbacks.get(target);\r\n    if (!keyToCallbacks.get(key)) {\r\n        keyToCallbacks.set(key, new Set());\r\n    }\r\n    keyToCallbacks.get(key).add(callback);\r\n    if (!callbacksToTargets.has(callback)) {\r\n        callbacksToTargets.set(callback, new Set());\r\n    }\r\n    callbacksToTargets.get(callback).add(target);\r\n}\r\n/**\r\n * Notify Reactives that are observing a given target that a key has changed on\r\n * the target.\r\n *\r\n * @param target target whose Reactives should be notified that the target was\r\n *  changed.\r\n * @param key the key that changed (or Symbol `KEYCHANGES` if a key was created\r\n *   or deleted)\r\n */\r\nfunction notifyReactives(target, key) {\r\n    const keyToCallbacks = targetToKeysToCallbacks.get(target);\r\n    if (!keyToCallbacks) {\r\n        return;\r\n    }\r\n    const callbacks = keyToCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    // Loop on copy because clearReactivesForCallback will modify the set in place\r\n    for (const callback of [...callbacks]) {\r\n        clearReactivesForCallback(callback);\r\n        callback();\r\n    }\r\n}\r\nconst callbacksToTargets = new WeakMap();\r\n/**\r\n * Clears all subscriptions of the Reactives associated with a given callback.\r\n *\r\n * @param callback the callback for which the reactives need to be cleared\r\n */\r\nfunction clearReactivesForCallback(callback) {\r\n    const targetsToClear = callbacksToTargets.get(callback);\r\n    if (!targetsToClear) {\r\n        return;\r\n    }\r\n    for (const target of targetsToClear) {\r\n        const observedKeys = targetToKeysToCallbacks.get(target);\r\n        if (!observedKeys) {\r\n            continue;\r\n        }\r\n        for (const [key, callbacks] of observedKeys.entries()) {\r\n            callbacks.delete(callback);\r\n            if (!callbacks.size) {\r\n                observedKeys.delete(key);\r\n            }\r\n        }\r\n    }\r\n    targetsToClear.clear();\r\n}\r\nfunction getSubscriptions(callback) {\r\n    const targets = callbacksToTargets.get(callback) || [];\r\n    return [...targets].map((target) => {\r\n        const keysToCallbacks = targetToKeysToCallbacks.get(target);\r\n        let keys = [];\r\n        if (keysToCallbacks) {\r\n            for (const [key, cbs] of keysToCallbacks) {\r\n                if (cbs.has(callback)) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n        }\r\n        return { target, keys };\r\n    });\r\n}\r\n// Maps reactive objects to the underlying target\r\nconst targets = new WeakMap();\r\nconst reactiveCache = new WeakMap();\r\n/**\r\n * Creates a reactive proxy for an object. Reading data on the reactive object\r\n * subscribes to changes to the data. Writing data on the object will cause the\r\n * notify callback to be called if there are suscriptions to that data. Nested\r\n * objects and arrays are automatically made reactive as well.\r\n *\r\n * Whenever you are notified of a change, all subscriptions are cleared, and if\r\n * you would like to be notified of any further changes, you should go read\r\n * the underlying data again. We assume that if you don't go read it again after\r\n * being notified, it means that you are no longer interested in that data.\r\n *\r\n * Subscriptions:\r\n * + Reading a property on an object will subscribe you to changes in the value\r\n *    of that property.\r\n * + Accessing an object's keys (eg with Object.keys or with `for..in`) will\r\n *    subscribe you to the creation/deletion of keys. Checking the presence of a\r\n *    key on the object with 'in' has the same effect.\r\n * - getOwnPropertyDescriptor does not currently subscribe you to the property.\r\n *    This is a choice that was made because changing a key's value will trigger\r\n *    this trap and we do not want to subscribe by writes. This also means that\r\n *    Object.hasOwnProperty doesn't subscribe as it goes through this trap.\r\n *\r\n * @param target the object for which to create a reactive proxy\r\n * @param callback the function to call when an observed property of the\r\n *  reactive has changed\r\n * @returns a proxy that tracks changes to it\r\n */\r\nfunction reactive(target, callback = NO_CALLBACK) {\r\n    if (!canBeMadeReactive(target)) {\r\n        throw new OwlError(`Cannot make the given value reactive`);\r\n    }\r\n    if (skipped.has(target)) {\r\n        return target;\r\n    }\r\n    if (targets.has(target)) {\r\n        // target is reactive, create a reactive on the underlying object instead\r\n        return reactive(targets.get(target), callback);\r\n    }\r\n    if (!reactiveCache.has(target)) {\r\n        reactiveCache.set(target, new WeakMap());\r\n    }\r\n    const reactivesForTarget = reactiveCache.get(target);\r\n    if (!reactivesForTarget.has(callback)) {\r\n        const targetRawType = rawType(target);\r\n        const handler = COLLECTION_RAW_TYPES.includes(targetRawType)\r\n            ? collectionsProxyHandler(target, callback, targetRawType)\r\n            : basicProxyHandler(callback);\r\n        const proxy = new Proxy(target, handler);\r\n        reactivesForTarget.set(callback, proxy);\r\n        targets.set(proxy, target);\r\n    }\r\n    return reactivesForTarget.get(callback);\r\n}\r\n/**\r\n * Creates a basic proxy handler for regular objects and arrays.\r\n *\r\n * @param callback @see reactive\r\n * @returns a proxy handler object\r\n */\r\nfunction basicProxyHandler(callback) {\r\n    return {\r\n        get(target, key, receiver) {\r\n            // non-writable non-configurable properties cannot be made reactive\r\n            const desc = Object.getOwnPropertyDescriptor(target, key);\r\n            if (desc && !desc.writable && !desc.configurable) {\r\n                return Reflect.get(target, key, receiver);\r\n            }\r\n            observeTargetKey(target, key, callback);\r\n            return possiblyReactive(Reflect.get(target, key, receiver), callback);\r\n        },\r\n        set(target, key, value, receiver) {\r\n            const hadKey = objectHasOwnProperty.call(target, key);\r\n            const originalValue = Reflect.get(target, key, receiver);\r\n            const ret = Reflect.set(target, key, toRaw(value), receiver);\r\n            if (!hadKey && objectHasOwnProperty.call(target, key)) {\r\n                notifyReactives(target, KEYCHANGES);\r\n            }\r\n            // While Array length may trigger the set trap, it's not actually set by this\r\n            // method but is updated behind the scenes, and the trap is not called with the\r\n            // new value. We disable the \"same-value-optimization\" for it because of that.\r\n            if (originalValue !== Reflect.get(target, key, receiver) ||\r\n                (key === \"length\" && Array.isArray(target))) {\r\n                notifyReactives(target, key);\r\n            }\r\n            return ret;\r\n        },\r\n        deleteProperty(target, key) {\r\n            const ret = Reflect.deleteProperty(target, key);\r\n            // TODO: only notify when something was actually deleted\r\n            notifyReactives(target, KEYCHANGES);\r\n            notifyReactives(target, key);\r\n            return ret;\r\n        },\r\n        ownKeys(target) {\r\n            observeTargetKey(target, KEYCHANGES, callback);\r\n            return Reflect.ownKeys(target);\r\n        },\r\n        has(target, key) {\r\n            // TODO: this observes all key changes instead of only the presence of the argument key\r\n            // observing the key itself would observe value changes instead of presence changes\r\n            // so we may need a finer grained system to distinguish observing value vs presence.\r\n            observeTargetKey(target, KEYCHANGES, callback);\r\n            return Reflect.has(target, key);\r\n        },\r\n    };\r\n}\r\n/**\r\n * Creates a function that will observe the key that is passed to it when called\r\n * and delegates to the underlying method.\r\n *\r\n * @param methodName name of the method to delegate to\r\n * @param target @see reactive\r\n * @param callback @see reactive\r\n */\r\nfunction makeKeyObserver(methodName, target, callback) {\r\n    return (key) => {\r\n        key = toRaw(key);\r\n        observeTargetKey(target, key, callback);\r\n        return possiblyReactive(target[methodName](key), callback);\r\n    };\r\n}\r\n/**\r\n * Creates an iterable that will delegate to the underlying iteration method and\r\n * observe keys as necessary.\r\n *\r\n * @param methodName name of the method to delegate to\r\n * @param target @see reactive\r\n * @param callback @see reactive\r\n */\r\nfunction makeIteratorObserver(methodName, target, callback) {\r\n    return function* () {\r\n        observeTargetKey(target, KEYCHANGES, callback);\r\n        const keys = target.keys();\r\n        for (const item of target[methodName]()) {\r\n            const key = keys.next().value;\r\n            observeTargetKey(target, key, callback);\r\n            yield possiblyReactive(item, callback);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Creates a forEach function that will delegate to forEach on the underlying\r\n * collection while observing key changes, and keys as they're iterated over,\r\n * and making the passed keys/values reactive.\r\n *\r\n * @param target @see reactive\r\n * @param callback @see reactive\r\n */\r\nfunction makeForEachObserver(target, callback) {\r\n    return function forEach(forEachCb, thisArg) {\r\n        observeTargetKey(target, KEYCHANGES, callback);\r\n        target.forEach(function (val, key, targetObj) {\r\n            observeTargetKey(target, key, callback);\r\n            forEachCb.call(thisArg, possiblyReactive(val, callback), possiblyReactive(key, callback), possiblyReactive(targetObj, callback));\r\n        }, thisArg);\r\n    };\r\n}\r\n/**\r\n * Creates a function that will delegate to an underlying method, and check if\r\n * that method has modified the presence or value of a key, and notify the\r\n * reactives appropriately.\r\n *\r\n * @param setterName name of the method to delegate to\r\n * @param getterName name of the method which should be used to retrieve the\r\n *  value before calling the delegate method for comparison purposes\r\n * @param target @see reactive\r\n */\r\nfunction delegateAndNotify(setterName, getterName, target) {\r\n    return (key, value) => {\r\n        key = toRaw(key);\r\n        const hadKey = target.has(key);\r\n        const originalValue = target[getterName](key);\r\n        const ret = target[setterName](key, value);\r\n        const hasKey = target.has(key);\r\n        if (hadKey !== hasKey) {\r\n            notifyReactives(target, KEYCHANGES);\r\n        }\r\n        if (originalValue !== target[getterName](key)) {\r\n            notifyReactives(target, key);\r\n        }\r\n        return ret;\r\n    };\r\n}\r\n/**\r\n * Creates a function that will clear the underlying collection and notify that\r\n * the keys of the collection have changed.\r\n *\r\n * @param target @see reactive\r\n */\r\nfunction makeClearNotifier(target) {\r\n    return () => {\r\n        const allKeys = [...target.keys()];\r\n        target.clear();\r\n        notifyReactives(target, KEYCHANGES);\r\n        for (const key of allKeys) {\r\n            notifyReactives(target, key);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Maps raw type of an object to an object containing functions that can be used\r\n * to build an appropritate proxy handler for that raw type. Eg: when making a\r\n * reactive set, calling the has method should mark the key that is being\r\n * retrieved as observed, and calling the add or delete method should notify the\r\n * reactives that the key which is being added or deleted has been modified.\r\n */\r\nconst rawTypeToFuncHandlers = {\r\n    Set: (target, callback) => ({\r\n        has: makeKeyObserver(\"has\", target, callback),\r\n        add: delegateAndNotify(\"add\", \"has\", target),\r\n        delete: delegateAndNotify(\"delete\", \"has\", target),\r\n        keys: makeIteratorObserver(\"keys\", target, callback),\r\n        values: makeIteratorObserver(\"values\", target, callback),\r\n        entries: makeIteratorObserver(\"entries\", target, callback),\r\n        [Symbol.iterator]: makeIteratorObserver(Symbol.iterator, target, callback),\r\n        forEach: makeForEachObserver(target, callback),\r\n        clear: makeClearNotifier(target),\r\n        get size() {\r\n            observeTargetKey(target, KEYCHANGES, callback);\r\n            return target.size;\r\n        },\r\n    }),\r\n    Map: (target, callback) => ({\r\n        has: makeKeyObserver(\"has\", target, callback),\r\n        get: makeKeyObserver(\"get\", target, callback),\r\n        set: delegateAndNotify(\"set\", \"get\", target),\r\n        delete: delegateAndNotify(\"delete\", \"has\", target),\r\n        keys: makeIteratorObserver(\"keys\", target, callback),\r\n        values: makeIteratorObserver(\"values\", target, callback),\r\n        entries: makeIteratorObserver(\"entries\", target, callback),\r\n        [Symbol.iterator]: makeIteratorObserver(Symbol.iterator, target, callback),\r\n        forEach: makeForEachObserver(target, callback),\r\n        clear: makeClearNotifier(target),\r\n        get size() {\r\n            observeTargetKey(target, KEYCHANGES, callback);\r\n            return target.size;\r\n        },\r\n    }),\r\n    WeakMap: (target, callback) => ({\r\n        has: makeKeyObserver(\"has\", target, callback),\r\n        get: makeKeyObserver(\"get\", target, callback),\r\n        set: delegateAndNotify(\"set\", \"get\", target),\r\n        delete: delegateAndNotify(\"delete\", \"has\", target),\r\n    }),\r\n};\r\n/**\r\n * Creates a proxy handler for collections (Set/Map/WeakMap)\r\n *\r\n * @param callback @see reactive\r\n * @param target @see reactive\r\n * @returns a proxy handler object\r\n */\r\nfunction collectionsProxyHandler(target, callback, targetRawType) {\r\n    // TODO: if performance is an issue we can create the special handlers lazily when each\r\n    // property is read.\r\n    const specialHandlers = rawTypeToFuncHandlers[targetRawType](target, callback);\r\n    return Object.assign(basicProxyHandler(callback), {\r\n        // FIXME: probably broken when part of prototype chain since we ignore the receiver\r\n        get(target, key) {\r\n            if (objectHasOwnProperty.call(specialHandlers, key)) {\r\n                return specialHandlers[key];\r\n            }\r\n            observeTargetKey(target, key, callback);\r\n            return possiblyReactive(target[key], callback);\r\n        },\r\n    });\r\n}\n\nlet currentNode = null;\r\nfunction saveCurrent() {\r\n    let n = currentNode;\r\n    return () => {\r\n        currentNode = n;\r\n    };\r\n}\r\nfunction getCurrent() {\r\n    if (!currentNode) {\r\n        throw new OwlError(\"No active component (a hook function should only be called in 'setup')\");\r\n    }\r\n    return currentNode;\r\n}\r\nfunction useComponent() {\r\n    return currentNode.component;\r\n}\r\n/**\r\n * Apply default props (only top level).\r\n */\r\nfunction applyDefaultProps(props, defaultProps) {\r\n    for (let propName in defaultProps) {\r\n        if (props[propName] === undefined) {\r\n            props[propName] = defaultProps[propName];\r\n        }\r\n    }\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Integration with reactivity system (useState)\r\n// -----------------------------------------------------------------------------\r\nconst batchedRenderFunctions = new WeakMap();\r\n/**\r\n * Creates a reactive object that will be observed by the current component.\r\n * Reading data from the returned object (eg during rendering) will cause the\r\n * component to subscribe to that data and be rerendered when it changes.\r\n *\r\n * @param state the state to observe\r\n * @returns a reactive object that will cause the component to re-render on\r\n *  relevant changes\r\n * @see reactive\r\n */\r\nfunction useState(state) {\r\n    const node = getCurrent();\r\n    let render = batchedRenderFunctions.get(node);\r\n    if (!render) {\r\n        render = batched(node.render.bind(node, false));\r\n        batchedRenderFunctions.set(node, render);\r\n        // manual implementation of onWillDestroy to break cyclic dependency\r\n        node.willDestroy.push(clearReactivesForCallback.bind(null, render));\r\n    }\r\n    return reactive(state, render);\r\n}\r\nclass ComponentNode {\r\n    constructor(C, props, app, parent, parentKey) {\r\n        this.fiber = null;\r\n        this.bdom = null;\r\n        this.status = 0 /* NEW */;\r\n        this.forceNextRender = false;\r\n        this.nextProps = null;\r\n        this.children = Object.create(null);\r\n        this.refs = {};\r\n        this.willStart = [];\r\n        this.willUpdateProps = [];\r\n        this.willUnmount = [];\r\n        this.mounted = [];\r\n        this.willPatch = [];\r\n        this.patched = [];\r\n        this.willDestroy = [];\r\n        currentNode = this;\r\n        this.app = app;\r\n        this.parent = parent;\r\n        this.props = props;\r\n        this.parentKey = parentKey;\r\n        const defaultProps = C.defaultProps;\r\n        props = Object.assign({}, props);\r\n        if (defaultProps) {\r\n            applyDefaultProps(props, defaultProps);\r\n        }\r\n        const env = (parent && parent.childEnv) || app.env;\r\n        this.childEnv = env;\r\n        for (const key in props) {\r\n            const prop = props[key];\r\n            if (prop && typeof prop === \"object\" && targets.has(prop)) {\r\n                props[key] = useState(prop);\r\n            }\r\n        }\r\n        this.component = new C(props, env, this);\r\n        const ctx = Object.assign(Object.create(this.component), { this: this.component });\r\n        this.renderFn = app.getTemplate(C.template).bind(this.component, ctx, this);\r\n        this.component.setup();\r\n        currentNode = null;\r\n    }\r\n    mountComponent(target, options) {\r\n        const fiber = new MountFiber(this, target, options);\r\n        this.app.scheduler.addFiber(fiber);\r\n        this.initiateRender(fiber);\r\n    }\r\n    async initiateRender(fiber) {\r\n        this.fiber = fiber;\r\n        if (this.mounted.length) {\r\n            fiber.root.mounted.push(fiber);\r\n        }\r\n        const component = this.component;\r\n        try {\r\n            await Promise.all(this.willStart.map((f) => f.call(component)));\r\n        }\r\n        catch (e) {\r\n            this.app.handleError({ node: this, error: e });\r\n            return;\r\n        }\r\n        if (this.status === 0 /* NEW */ && this.fiber === fiber) {\r\n            fiber.render();\r\n        }\r\n    }\r\n    async render(deep) {\r\n        if (this.status >= 2 /* CANCELLED */) {\r\n            return;\r\n        }\r\n        let current = this.fiber;\r\n        if (current && (current.root.locked || current.bdom === true)) {\r\n            await Promise.resolve();\r\n            // situation may have changed after the microtask tick\r\n            current = this.fiber;\r\n        }\r\n        if (current) {\r\n            if (!current.bdom && !fibersInError.has(current)) {\r\n                if (deep) {\r\n                    // we want the render from this point on to be with deep=true\r\n                    current.deep = deep;\r\n                }\r\n                return;\r\n            }\r\n            // if current rendering was with deep=true, we want this one to be the same\r\n            deep = deep || current.deep;\r\n        }\r\n        else if (!this.bdom) {\r\n            return;\r\n        }\r\n        const fiber = makeRootFiber(this);\r\n        fiber.deep = deep;\r\n        this.fiber = fiber;\r\n        this.app.scheduler.addFiber(fiber);\r\n        await Promise.resolve();\r\n        if (this.status >= 2 /* CANCELLED */) {\r\n            return;\r\n        }\r\n        // We only want to actually render the component if the following two\r\n        // conditions are true:\r\n        // * this.fiber: it could be null, in which case the render has been cancelled\r\n        // * (current || !fiber.parent): if current is not null, this means that the\r\n        //   render function was called when a render was already occurring. In this\r\n        //   case, the pending rendering was cancelled, and the fiber needs to be\r\n        //   rendered to complete the work.  If current is null, we check that the\r\n        //   fiber has no parent.  If that is the case, the fiber was downgraded from\r\n        //   a root fiber to a child fiber in the previous microtick, because it was\r\n        //   embedded in a rendering coming from above, so the fiber will be rendered\r\n        //   in the next microtick anyway, so we should not render it again.\r\n        if (this.fiber === fiber && (current || !fiber.parent)) {\r\n            fiber.render();\r\n        }\r\n    }\r\n    cancel() {\r\n        this._cancel();\r\n        delete this.parent.children[this.parentKey];\r\n        this.app.scheduler.scheduleDestroy(this);\r\n    }\r\n    _cancel() {\r\n        this.status = 2 /* CANCELLED */;\r\n        const children = this.children;\r\n        for (let childKey in children) {\r\n            children[childKey]._cancel();\r\n        }\r\n    }\r\n    destroy() {\r\n        let shouldRemove = this.status === 1 /* MOUNTED */;\r\n        this._destroy();\r\n        if (shouldRemove) {\r\n            this.bdom.remove();\r\n        }\r\n    }\r\n    _destroy() {\r\n        const component = this.component;\r\n        if (this.status === 1 /* MOUNTED */) {\r\n            for (let cb of this.willUnmount) {\r\n                cb.call(component);\r\n            }\r\n        }\r\n        for (let child of Object.values(this.children)) {\r\n            child._destroy();\r\n        }\r\n        if (this.willDestroy.length) {\r\n            try {\r\n                for (let cb of this.willDestroy) {\r\n                    cb.call(component);\r\n                }\r\n            }\r\n            catch (e) {\r\n                this.app.handleError({ error: e, node: this });\r\n            }\r\n        }\r\n        this.status = 3 /* DESTROYED */;\r\n    }\r\n    async updateAndRender(props, parentFiber) {\r\n        this.nextProps = props;\r\n        props = Object.assign({}, props);\r\n        // update\r\n        const fiber = makeChildFiber(this, parentFiber);\r\n        this.fiber = fiber;\r\n        const component = this.component;\r\n        const defaultProps = component.constructor.defaultProps;\r\n        if (defaultProps) {\r\n            applyDefaultProps(props, defaultProps);\r\n        }\r\n        currentNode = this;\r\n        for (const key in props) {\r\n            const prop = props[key];\r\n            if (prop && typeof prop === \"object\" && targets.has(prop)) {\r\n                props[key] = useState(prop);\r\n            }\r\n        }\r\n        currentNode = null;\r\n        const prom = Promise.all(this.willUpdateProps.map((f) => f.call(component, props)));\r\n        await prom;\r\n        if (fiber !== this.fiber) {\r\n            return;\r\n        }\r\n        component.props = props;\r\n        fiber.render();\r\n        const parentRoot = parentFiber.root;\r\n        if (this.willPatch.length) {\r\n            parentRoot.willPatch.push(fiber);\r\n        }\r\n        if (this.patched.length) {\r\n            parentRoot.patched.push(fiber);\r\n        }\r\n    }\r\n    /**\r\n     * Finds a child that has dom that is not yet updated, and update it. This\r\n     * method is meant to be used only in the context of repatching the dom after\r\n     * a mounted hook failed and was handled.\r\n     */\r\n    updateDom() {\r\n        if (!this.fiber) {\r\n            return;\r\n        }\r\n        if (this.bdom === this.fiber.bdom) {\r\n            // If the error was handled by some child component, we need to find it to\r\n            // apply its change\r\n            for (let k in this.children) {\r\n                const child = this.children[k];\r\n                child.updateDom();\r\n            }\r\n        }\r\n        else {\r\n            // if we get here, this is the component that handled the error and rerendered\r\n            // itself, so we can simply patch the dom\r\n            this.bdom.patch(this.fiber.bdom, false);\r\n            this.fiber.appliedToDom = true;\r\n            this.fiber = null;\r\n        }\r\n    }\r\n    /**\r\n     * Sets a ref to a given HTMLElement.\r\n     *\r\n     * @param name the name of the ref to set\r\n     * @param el the HTMLElement to set the ref to. The ref is not set if the el\r\n     *  is null, but useRef will not return elements that are not in the DOM\r\n     */\r\n    setRef(name, el) {\r\n        if (el) {\r\n            this.refs[name] = el;\r\n        }\r\n    }\r\n    // ---------------------------------------------------------------------------\r\n    // Block DOM methods\r\n    // ---------------------------------------------------------------------------\r\n    firstNode() {\r\n        const bdom = this.bdom;\r\n        return bdom ? bdom.firstNode() : undefined;\r\n    }\r\n    mount(parent, anchor) {\r\n        const bdom = this.fiber.bdom;\r\n        this.bdom = bdom;\r\n        bdom.mount(parent, anchor);\r\n        this.status = 1 /* MOUNTED */;\r\n        this.fiber.appliedToDom = true;\r\n        this.children = this.fiber.childrenMap;\r\n        this.fiber = null;\r\n    }\r\n    moveBeforeDOMNode(node, parent) {\r\n        this.bdom.moveBeforeDOMNode(node, parent);\r\n    }\r\n    moveBeforeVNode(other, afterNode) {\r\n        this.bdom.moveBeforeVNode(other ? other.bdom : null, afterNode);\r\n    }\r\n    patch() {\r\n        if (this.fiber && this.fiber.parent) {\r\n            // we only patch here renderings coming from above. renderings initiated\r\n            // by the component will be patched independently in the appropriate\r\n            // fiber.complete\r\n            this._patch();\r\n            this.props = this.nextProps;\r\n        }\r\n    }\r\n    _patch() {\r\n        let hasChildren = false;\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        for (let _k in this.children) {\r\n            hasChildren = true;\r\n            break;\r\n        }\r\n        const fiber = this.fiber;\r\n        this.children = fiber.childrenMap;\r\n        this.bdom.patch(fiber.bdom, hasChildren);\r\n        fiber.appliedToDom = true;\r\n        this.fiber = null;\r\n    }\r\n    beforeRemove() {\r\n        this._destroy();\r\n    }\r\n    remove() {\r\n        this.bdom.remove();\r\n    }\r\n    // ---------------------------------------------------------------------------\r\n    // Some debug helpers\r\n    // ---------------------------------------------------------------------------\r\n    get name() {\r\n        return this.component.constructor.name;\r\n    }\r\n    get subscriptions() {\r\n        const render = batchedRenderFunctions.get(this);\r\n        return render ? getSubscriptions(render) : [];\r\n    }\r\n}\n\nconst TIMEOUT = Symbol(\"timeout\");\r\nconst HOOK_TIMEOUT = {\r\n    onWillStart: 3000,\r\n    onWillUpdateProps: 3000,\r\n};\r\nfunction wrapError(fn, hookName) {\r\n    const error = new OwlError();\r\n    const timeoutError = new OwlError();\r\n    const node = getCurrent();\r\n    return (...args) => {\r\n        const onError = (cause) => {\r\n            error.cause = cause;\r\n            error.message =\r\n                cause instanceof Error\r\n                    ? `The following error occurred in ${hookName}: \"${cause.message}\"`\r\n                    : `Something that is not an Error was thrown in ${hookName} (see this Error's \"cause\" property)`;\r\n            throw error;\r\n        };\r\n        let result;\r\n        try {\r\n            result = fn(...args);\r\n        }\r\n        catch (cause) {\r\n            onError(cause);\r\n        }\r\n        if (!(result instanceof Promise)) {\r\n            return result;\r\n        }\r\n        const timeout = HOOK_TIMEOUT[hookName];\r\n        if (timeout) {\r\n            const fiber = node.fiber;\r\n            Promise.race([\r\n                result.catch(() => { }),\r\n                new Promise((resolve) => setTimeout(() => resolve(TIMEOUT), timeout)),\r\n            ]).then((res) => {\r\n                if (res === TIMEOUT && node.fiber === fiber && node.status <= 2) {\r\n                    timeoutError.message = `${hookName}'s promise hasn't resolved after ${timeout / 1000} seconds`;\r\n                    console.log(timeoutError);\r\n                }\r\n            });\r\n        }\r\n        return result.catch(onError);\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n//  hooks\r\n// -----------------------------------------------------------------------------\r\nfunction onWillStart(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.willStart.push(decorate(fn.bind(node.component), \"onWillStart\"));\r\n}\r\nfunction onWillUpdateProps(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.willUpdateProps.push(decorate(fn.bind(node.component), \"onWillUpdateProps\"));\r\n}\r\nfunction onMounted(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.mounted.push(decorate(fn.bind(node.component), \"onMounted\"));\r\n}\r\nfunction onWillPatch(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.willPatch.unshift(decorate(fn.bind(node.component), \"onWillPatch\"));\r\n}\r\nfunction onPatched(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.patched.push(decorate(fn.bind(node.component), \"onPatched\"));\r\n}\r\nfunction onWillUnmount(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.willUnmount.unshift(decorate(fn.bind(node.component), \"onWillUnmount\"));\r\n}\r\nfunction onWillDestroy(fn) {\r\n    const node = getCurrent();\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    node.willDestroy.push(decorate(fn.bind(node.component), \"onWillDestroy\"));\r\n}\r\nfunction onWillRender(fn) {\r\n    const node = getCurrent();\r\n    const renderFn = node.renderFn;\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    fn = decorate(fn.bind(node.component), \"onWillRender\");\r\n    node.renderFn = () => {\r\n        fn();\r\n        return renderFn();\r\n    };\r\n}\r\nfunction onRendered(fn) {\r\n    const node = getCurrent();\r\n    const renderFn = node.renderFn;\r\n    const decorate = node.app.dev ? wrapError : (fn) => fn;\r\n    fn = decorate(fn.bind(node.component), \"onRendered\");\r\n    node.renderFn = () => {\r\n        const result = renderFn();\r\n        fn();\r\n        return result;\r\n    };\r\n}\r\nfunction onError(callback) {\r\n    const node = getCurrent();\r\n    let handlers = nodeErrorHandlers.get(node);\r\n    if (!handlers) {\r\n        handlers = [];\r\n        nodeErrorHandlers.set(node, handlers);\r\n    }\r\n    handlers.push(callback.bind(node.component));\r\n}\n\nclass Component {\r\n    constructor(props, env, node) {\r\n        this.props = props;\r\n        this.env = env;\r\n        this.__owl__ = node;\r\n    }\r\n    setup() { }\r\n    render(deep = false) {\r\n        this.__owl__.render(deep === true);\r\n    }\r\n}\r\nComponent.template = \"\";\n\nconst VText = text(\"\").constructor;\r\nclass VPortal extends VText {\r\n    constructor(selector, content) {\r\n        super(\"\");\r\n        this.target = null;\r\n        this.selector = selector;\r\n        this.content = content;\r\n    }\r\n    mount(parent, anchor) {\r\n        super.mount(parent, anchor);\r\n        this.target = document.querySelector(this.selector);\r\n        if (this.target) {\r\n            this.content.mount(this.target, null);\r\n        }\r\n        else {\r\n            this.content.mount(parent, anchor);\r\n        }\r\n    }\r\n    beforeRemove() {\r\n        this.content.beforeRemove();\r\n    }\r\n    remove() {\r\n        if (this.content) {\r\n            super.remove();\r\n            this.content.remove();\r\n            this.content = null;\r\n        }\r\n    }\r\n    patch(other) {\r\n        super.patch(other);\r\n        if (this.content) {\r\n            this.content.patch(other.content, true);\r\n        }\r\n        else {\r\n            this.content = other.content;\r\n            this.content.mount(this.target, null);\r\n        }\r\n    }\r\n}\r\n/**\r\n * kind of similar to <t t-slot=\"default\"/>, but it wraps it around a VPortal\r\n */\r\nfunction portalTemplate(app, bdom, helpers) {\r\n    let { callSlot } = helpers;\r\n    return function template(ctx, node, key = \"\") {\r\n        return new VPortal(ctx.props.target, callSlot(ctx, node, key, \"default\", false, null));\r\n    };\r\n}\r\nclass Portal extends Component {\r\n    setup() {\r\n        const node = this.__owl__;\r\n        onMounted(() => {\r\n            const portal = node.bdom;\r\n            if (!portal.target) {\r\n                const target = document.querySelector(this.props.target);\r\n                if (target) {\r\n                    portal.content.moveBeforeDOMNode(target.firstChild, target);\r\n                }\r\n                else {\r\n                    throw new OwlError(\"invalid portal target\");\r\n                }\r\n            }\r\n        });\r\n        onWillUnmount(() => {\r\n            const portal = node.bdom;\r\n            portal.remove();\r\n        });\r\n    }\r\n}\r\nPortal.template = \"__portal__\";\r\nPortal.props = {\r\n    target: {\r\n        type: String,\r\n    },\r\n    slots: true,\r\n};\n\n// -----------------------------------------------------------------------------\r\n// helpers\r\n// -----------------------------------------------------------------------------\r\nconst isUnionType = (t) => Array.isArray(t);\r\nconst isBaseType = (t) => typeof t !== \"object\";\r\nconst isValueType = (t) => typeof t === \"object\" && t && \"value\" in t;\r\nfunction isOptional(t) {\r\n    return typeof t === \"object\" && \"optional\" in t ? t.optional || false : false;\r\n}\r\nfunction describeType(type) {\r\n    return type === \"*\" || type === true ? \"value\" : type.name.toLowerCase();\r\n}\r\nfunction describe(info) {\r\n    if (isBaseType(info)) {\r\n        return describeType(info);\r\n    }\r\n    else if (isUnionType(info)) {\r\n        return info.map(describe).join(\" or \");\r\n    }\r\n    else if (isValueType(info)) {\r\n        return String(info.value);\r\n    }\r\n    if (\"element\" in info) {\r\n        return `list of ${describe({ type: info.element, optional: false })}s`;\r\n    }\r\n    if (\"shape\" in info) {\r\n        return `object`;\r\n    }\r\n    return describe(info.type || \"*\");\r\n}\r\nfunction toSchema(spec) {\r\n    return Object.fromEntries(spec.map((e) => e.endsWith(\"?\") ? [e.slice(0, -1), { optional: true }] : [e, { type: \"*\", optional: false }]));\r\n}\r\n/**\r\n * Main validate function\r\n */\r\nfunction validate(obj, spec) {\r\n    let errors = validateSchema(obj, spec);\r\n    if (errors.length) {\r\n        throw new OwlError(\"Invalid object: \" + errors.join(\", \"));\r\n    }\r\n}\r\n/**\r\n * Helper validate function, to get the list of errors. useful if one want to\r\n * manipulate the errors without parsing an error object\r\n */\r\nfunction validateSchema(obj, schema) {\r\n    if (Array.isArray(schema)) {\r\n        schema = toSchema(schema);\r\n    }\r\n    obj = toRaw(obj);\r\n    let errors = [];\r\n    // check if each value in obj has correct shape\r\n    for (let key in obj) {\r\n        if (key in schema) {\r\n            let result = validateType(key, obj[key], schema[key]);\r\n            if (result) {\r\n                errors.push(result);\r\n            }\r\n        }\r\n        else if (!(\"*\" in schema)) {\r\n            errors.push(`unknown key '${key}'`);\r\n        }\r\n    }\r\n    // check that all specified keys are defined in obj\r\n    for (let key in schema) {\r\n        const spec = schema[key];\r\n        if (key !== \"*\" && !isOptional(spec) && !(key in obj)) {\r\n            const isObj = typeof spec === \"object\" && !Array.isArray(spec);\r\n            const isAny = spec === \"*\" || (isObj && \"type\" in spec ? spec.type === \"*\" : isObj);\r\n            let detail = isAny ? \"\" : ` (should be a ${describe(spec)})`;\r\n            errors.push(`'${key}' is missing${detail}`);\r\n        }\r\n    }\r\n    return errors;\r\n}\r\nfunction validateBaseType(key, value, type) {\r\n    if (typeof type === \"function\") {\r\n        if (typeof value === \"object\") {\r\n            if (!(value instanceof type)) {\r\n                return `'${key}' is not a ${describeType(type)}`;\r\n            }\r\n        }\r\n        else if (typeof value !== type.name.toLowerCase()) {\r\n            return `'${key}' is not a ${describeType(type)}`;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction validateArrayType(key, value, descr) {\r\n    if (!Array.isArray(value)) {\r\n        return `'${key}' is not a list of ${describe(descr)}s`;\r\n    }\r\n    for (let i = 0; i < value.length; i++) {\r\n        const error = validateType(`${key}[${i}]`, value[i], descr);\r\n        if (error) {\r\n            return error;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction validateType(key, value, descr) {\r\n    if (value === undefined) {\r\n        return isOptional(descr) ? null : `'${key}' is undefined (should be a ${describe(descr)})`;\r\n    }\r\n    else if (isBaseType(descr)) {\r\n        return validateBaseType(key, value, descr);\r\n    }\r\n    else if (isValueType(descr)) {\r\n        return value === descr.value ? null : `'${key}' is not equal to '${descr.value}'`;\r\n    }\r\n    else if (isUnionType(descr)) {\r\n        let validDescr = descr.find((p) => !validateType(key, value, p));\r\n        return validDescr ? null : `'${key}' is not a ${describe(descr)}`;\r\n    }\r\n    let result = null;\r\n    if (\"element\" in descr) {\r\n        result = validateArrayType(key, value, descr.element);\r\n    }\r\n    else if (\"shape\" in descr) {\r\n        if (typeof value !== \"object\" || Array.isArray(value)) {\r\n            result = `'${key}' is not an object`;\r\n        }\r\n        else {\r\n            const errors = validateSchema(value, descr.shape);\r\n            if (errors.length) {\r\n                result = `'${key}' doesn't have the correct shape (${errors.join(\", \")})`;\r\n            }\r\n        }\r\n    }\r\n    else if (\"values\" in descr) {\r\n        if (typeof value !== \"object\" || Array.isArray(value)) {\r\n            result = `'${key}' is not an object`;\r\n        }\r\n        else {\r\n            const errors = Object.entries(value)\r\n                .map(([key, value]) => validateType(key, value, descr.values))\r\n                .filter(Boolean);\r\n            if (errors.length) {\r\n                result = `some of the values in '${key}' are invalid (${errors.join(\", \")})`;\r\n            }\r\n        }\r\n    }\r\n    if (\"type\" in descr && !result) {\r\n        result = validateType(key, value, descr.type);\r\n    }\r\n    if (\"validate\" in descr && !result) {\r\n        result = !descr.validate(value) ? `'${key}' is not valid` : null;\r\n    }\r\n    return result;\r\n}\n\nconst ObjectCreate = Object.create;\r\n/**\r\n * This file contains utility functions that will be injected in each template,\r\n * to perform various useful tasks in the compiled code.\r\n */\r\nfunction withDefault(value, defaultValue) {\r\n    return value === undefined || value === null || value === false ? defaultValue : value;\r\n}\r\nfunction callSlot(ctx, parent, key, name, dynamic, extra, defaultContent) {\r\n    key = key + \"__slot_\" + name;\r\n    const slots = ctx.props.slots || {};\r\n    const { __render, __ctx, __scope } = slots[name] || {};\r\n    const slotScope = ObjectCreate(__ctx || {});\r\n    if (__scope) {\r\n        slotScope[__scope] = extra;\r\n    }\r\n    const slotBDom = __render ? __render(slotScope, parent, key) : null;\r\n    if (defaultContent) {\r\n        let child1 = undefined;\r\n        let child2 = undefined;\r\n        if (slotBDom) {\r\n            child1 = dynamic ? toggler(name, slotBDom) : slotBDom;\r\n        }\r\n        else {\r\n            child2 = defaultContent(ctx, parent, key);\r\n        }\r\n        return multi([child1, child2]);\r\n    }\r\n    return slotBDom || text(\"\");\r\n}\r\nfunction capture(ctx) {\r\n    const result = ObjectCreate(ctx);\r\n    for (let k in ctx) {\r\n        result[k] = ctx[k];\r\n    }\r\n    return result;\r\n}\r\nfunction withKey(elem, k) {\r\n    elem.key = k;\r\n    return elem;\r\n}\r\nfunction prepareList(collection) {\r\n    let keys;\r\n    let values;\r\n    if (Array.isArray(collection)) {\r\n        keys = collection;\r\n        values = collection;\r\n    }\r\n    else if (collection instanceof Map) {\r\n        keys = [...collection.keys()];\r\n        values = [...collection.values()];\r\n    }\r\n    else if (Symbol.iterator in Object(collection)) {\r\n        keys = [...collection];\r\n        values = keys;\r\n    }\r\n    else if (collection && typeof collection === \"object\") {\r\n        values = Object.values(collection);\r\n        keys = Object.keys(collection);\r\n    }\r\n    else {\r\n        throw new OwlError(`Invalid loop expression: \"${collection}\" is not iterable`);\r\n    }\r\n    const n = values.length;\r\n    return [keys, values, n, new Array(n)];\r\n}\r\nconst isBoundary = Symbol(\"isBoundary\");\r\nfunction setContextValue(ctx, key, value) {\r\n    const ctx0 = ctx;\r\n    while (!ctx.hasOwnProperty(key) && !ctx.hasOwnProperty(isBoundary)) {\r\n        const newCtx = ctx.__proto__;\r\n        if (!newCtx) {\r\n            ctx = ctx0;\r\n            break;\r\n        }\r\n        ctx = newCtx;\r\n    }\r\n    ctx[key] = value;\r\n}\r\nfunction toNumber(val) {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n}\r\nfunction shallowEqual(l1, l2) {\r\n    for (let i = 0, l = l1.length; i < l; i++) {\r\n        if (l1[i] !== l2[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nclass LazyValue {\r\n    constructor(fn, ctx, component, node, key) {\r\n        this.fn = fn;\r\n        this.ctx = capture(ctx);\r\n        this.component = component;\r\n        this.node = node;\r\n        this.key = key;\r\n    }\r\n    evaluate() {\r\n        return this.fn.call(this.component, this.ctx, this.node, this.key);\r\n    }\r\n    toString() {\r\n        return this.evaluate().toString();\r\n    }\r\n}\r\n/*\r\n * Safely outputs `value` as a block depending on the nature of `value`\r\n */\r\nfunction safeOutput(value, defaultValue) {\r\n    if (value === undefined || value === null) {\r\n        return defaultValue ? toggler(\"default\", defaultValue) : toggler(\"undefined\", text(\"\"));\r\n    }\r\n    let safeKey;\r\n    let block;\r\n    switch (typeof value) {\r\n        case \"object\":\r\n            if (value instanceof Markup) {\r\n                safeKey = `string_safe`;\r\n                block = html(value);\r\n            }\r\n            else if (value instanceof LazyValue) {\r\n                safeKey = `lazy_value`;\r\n                block = value.evaluate();\r\n            }\r\n            else if (value instanceof String) {\r\n                safeKey = \"string_unsafe\";\r\n                block = text(value);\r\n            }\r\n            else {\r\n                // Assuming it is a block\r\n                safeKey = \"block_safe\";\r\n                block = value;\r\n            }\r\n            break;\r\n        case \"string\":\r\n            safeKey = \"string_unsafe\";\r\n            block = text(value);\r\n            break;\r\n        default:\r\n            safeKey = \"string_unsafe\";\r\n            block = text(String(value));\r\n    }\r\n    return toggler(safeKey, block);\r\n}\r\n/**\r\n * Validate the component props (or next props) against the (static) props\r\n * description.  This is potentially an expensive operation: it may needs to\r\n * visit recursively the props and all the children to check if they are valid.\r\n * This is why it is only done in 'dev' mode.\r\n */\r\nfunction validateProps(name, props, comp) {\r\n    const ComponentClass = typeof name !== \"string\"\r\n        ? name\r\n        : comp.constructor.components[name];\r\n    if (!ComponentClass) {\r\n        // this is an error, wrong component. We silently return here instead so the\r\n        // error is triggered by the usual path ('component' function)\r\n        return;\r\n    }\r\n    const schema = ComponentClass.props;\r\n    if (!schema) {\r\n        if (comp.__owl__.app.warnIfNoStaticProps) {\r\n            console.warn(`Component '${ComponentClass.name}' does not have a static props description`);\r\n        }\r\n        return;\r\n    }\r\n    const defaultProps = ComponentClass.defaultProps;\r\n    if (defaultProps) {\r\n        let isMandatory = (name) => Array.isArray(schema)\r\n            ? schema.includes(name)\r\n            : name in schema && !(\"*\" in schema) && !isOptional(schema[name]);\r\n        for (let p in defaultProps) {\r\n            if (isMandatory(p)) {\r\n                throw new OwlError(`A default value cannot be defined for a mandatory prop (name: '${p}', component: ${ComponentClass.name})`);\r\n            }\r\n        }\r\n    }\r\n    const errors = validateSchema(props, schema);\r\n    if (errors.length) {\r\n        throw new OwlError(`Invalid props for component '${ComponentClass.name}': ` + errors.join(\", \"));\r\n    }\r\n}\r\nfunction makeRefWrapper(node) {\r\n    let refNames = new Set();\r\n    return (name, fn) => {\r\n        if (refNames.has(name)) {\r\n            throw new OwlError(`Cannot set the same ref more than once in the same component, ref \"${name}\" was set multiple times in ${node.name}`);\r\n        }\r\n        refNames.add(name);\r\n        return fn;\r\n    };\r\n}\r\nconst helpers = {\r\n    withDefault,\r\n    zero: Symbol(\"zero\"),\r\n    isBoundary,\r\n    callSlot,\r\n    capture,\r\n    withKey,\r\n    prepareList,\r\n    setContextValue,\r\n    shallowEqual,\r\n    toNumber,\r\n    validateProps,\r\n    LazyValue,\r\n    safeOutput,\r\n    createCatcher,\r\n    markRaw,\r\n    OwlError,\r\n    makeRefWrapper,\r\n};\n\n/**\r\n * Parses an XML string into an XML document, throwing errors on parser errors\r\n * instead of returning an XML document containing the parseerror.\r\n *\r\n * @param xml the string to parse\r\n * @returns an XML document corresponding to the content of the string\r\n */\r\nfunction parseXML(xml) {\r\n    const parser = new DOMParser();\r\n    const doc = parser.parseFromString(xml, \"text/xml\");\r\n    if (doc.getElementsByTagName(\"parsererror\").length) {\r\n        let msg = \"Invalid XML in template.\";\r\n        const parsererrorText = doc.getElementsByTagName(\"parsererror\")[0].textContent;\r\n        if (parsererrorText) {\r\n            msg += \"\\nThe parser has produced the following error message:\\n\" + parsererrorText;\r\n            const re = /\\d+/g;\r\n            const firstMatch = re.exec(parsererrorText);\r\n            if (firstMatch) {\r\n                const lineNumber = Number(firstMatch[0]);\r\n                const line = xml.split(\"\\n\")[lineNumber - 1];\r\n                const secondMatch = re.exec(parsererrorText);\r\n                if (line && secondMatch) {\r\n                    const columnIndex = Number(secondMatch[0]) - 1;\r\n                    if (line[columnIndex]) {\r\n                        msg +=\r\n                            `\\nThe error might be located at xml line ${lineNumber} column ${columnIndex}\\n` +\r\n                                `${line}\\n${\"-\".repeat(columnIndex - 1)}^`;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        throw new OwlError(msg);\r\n    }\r\n    return doc;\r\n}\n\nconst bdom = { text, createBlock, list, multi, html, toggler, comment };\r\nclass TemplateSet {\r\n    constructor(config = {}) {\r\n        this.rawTemplates = Object.create(globalTemplates);\r\n        this.templates = {};\r\n        this.Portal = Portal;\r\n        this.dev = config.dev || false;\r\n        this.translateFn = config.translateFn;\r\n        this.translatableAttributes = config.translatableAttributes;\r\n        if (config.templates) {\r\n            if (config.templates instanceof Document || typeof config.templates === \"string\") {\r\n                this.addTemplates(config.templates);\r\n            }\r\n            else {\r\n                for (const name in config.templates) {\r\n                    this.addTemplate(name, config.templates[name]);\r\n                }\r\n            }\r\n        }\r\n        this.getRawTemplate = config.getTemplate;\r\n        this.customDirectives = config.customDirectives || {};\r\n        this.runtimeUtils = { ...helpers, __globals__: config.globalValues || {} };\r\n        this.hasGlobalValues = Boolean(config.globalValues && Object.keys(config.globalValues).length);\r\n    }\r\n    static registerTemplate(name, fn) {\r\n        globalTemplates[name] = fn;\r\n    }\r\n    addTemplate(name, template) {\r\n        if (name in this.rawTemplates) {\r\n            // this check can be expensive, just silently ignore double definitions outside dev mode\r\n            if (!this.dev) {\r\n                return;\r\n            }\r\n            const rawTemplate = this.rawTemplates[name];\r\n            const currentAsString = typeof rawTemplate === \"string\"\r\n                ? rawTemplate\r\n                : rawTemplate instanceof Element\r\n                    ? rawTemplate.outerHTML\r\n                    : rawTemplate.toString();\r\n            const newAsString = typeof template === \"string\" ? template : template.outerHTML;\r\n            if (currentAsString === newAsString) {\r\n                return;\r\n            }\r\n            throw new OwlError(`Template ${name} already defined with different content`);\r\n        }\r\n        this.rawTemplates[name] = template;\r\n    }\r\n    addTemplates(xml) {\r\n        if (!xml) {\r\n            // empty string\r\n            return;\r\n        }\r\n        xml = xml instanceof Document ? xml : parseXML(xml);\r\n        for (const template of xml.querySelectorAll(\"[t-name]\")) {\r\n            const name = template.getAttribute(\"t-name\");\r\n            this.addTemplate(name, template);\r\n        }\r\n    }\r\n    getTemplate(name) {\r\n        var _a;\r\n        if (!(name in this.templates)) {\r\n            const rawTemplate = ((_a = this.getRawTemplate) === null || _a === void 0 ? void 0 : _a.call(this, name)) || this.rawTemplates[name];\r\n            if (rawTemplate === undefined) {\r\n                let extraInfo = \"\";\r\n                try {\r\n                    const componentName = getCurrent().component.constructor.name;\r\n                    extraInfo = ` (for component \"${componentName}\")`;\r\n                }\r\n                catch { }\r\n                throw new OwlError(`Missing template: \"${name}\"${extraInfo}`);\r\n            }\r\n            const isFn = typeof rawTemplate === \"function\" && !(rawTemplate instanceof Element);\r\n            const templateFn = isFn ? rawTemplate : this._compileTemplate(name, rawTemplate);\r\n            // first add a function to lazily get the template, in case there is a\r\n            // recursive call to the template name\r\n            const templates = this.templates;\r\n            this.templates[name] = function (context, parent) {\r\n                return templates[name].call(this, context, parent);\r\n            };\r\n            const template = templateFn(this, bdom, this.runtimeUtils);\r\n            this.templates[name] = template;\r\n        }\r\n        return this.templates[name];\r\n    }\r\n    _compileTemplate(name, template) {\r\n        throw new OwlError(`Unable to compile a template. Please use owl full build instead`);\r\n    }\r\n    callTemplate(owner, subTemplate, ctx, parent, key) {\r\n        const template = this.getTemplate(subTemplate);\r\n        return toggler(subTemplate, template.call(owner, ctx, parent, key + subTemplate));\r\n    }\r\n}\r\n// -----------------------------------------------------------------------------\r\n//  xml tag helper\r\n// -----------------------------------------------------------------------------\r\nconst globalTemplates = {};\r\nfunction xml(...args) {\r\n    const name = `__template__${xml.nextId++}`;\r\n    const value = String.raw(...args);\r\n    globalTemplates[name] = value;\r\n    return name;\r\n}\r\nxml.nextId = 1;\r\nTemplateSet.registerTemplate(\"__portal__\", portalTemplate);\n\n/**\r\n * Owl QWeb Expression Parser\r\n *\r\n * Owl needs in various contexts to be able to understand the structure of a\r\n * string representing a javascript expression.  The usual goal is to be able\r\n * to rewrite some variables.  For example, if a template has\r\n *\r\n *  ```xml\r\n *  <t t-if=\"computeSomething({val: state.val})\">...</t>\r\n * ```\r\n *\r\n * this needs to be translated in something like this:\r\n *\r\n * ```js\r\n *   if (context[\"computeSomething\"]({val: context[\"state\"].val})) { ... }\r\n * ```\r\n *\r\n * This file contains the implementation of an extremely naive tokenizer/parser\r\n * and evaluator for javascript expressions.  The supported grammar is basically\r\n * only expressive enough to understand the shape of objects, of arrays, and\r\n * various operators.\r\n */\r\n//------------------------------------------------------------------------------\r\n// Misc types, constants and helpers\r\n//------------------------------------------------------------------------------\r\nconst RESERVED_WORDS = \"true,false,NaN,null,undefined,debugger,console,window,in,instanceof,new,function,return,eval,void,Math,RegExp,Array,Object,Date,__globals__\".split(\",\");\r\nconst WORD_REPLACEMENT = Object.assign(Object.create(null), {\r\n    and: \"&&\",\r\n    or: \"||\",\r\n    gt: \">\",\r\n    gte: \">=\",\r\n    lt: \"<\",\r\n    lte: \"<=\",\r\n});\r\nconst STATIC_TOKEN_MAP = Object.assign(Object.create(null), {\r\n    \"{\": \"LEFT_BRACE\",\r\n    \"}\": \"RIGHT_BRACE\",\r\n    \"[\": \"LEFT_BRACKET\",\r\n    \"]\": \"RIGHT_BRACKET\",\r\n    \":\": \"COLON\",\r\n    \",\": \"COMMA\",\r\n    \"(\": \"LEFT_PAREN\",\r\n    \")\": \"RIGHT_PAREN\",\r\n});\r\n// note that the space after typeof is relevant. It makes sure that the formatted\r\n// expression has a space after typeof. Currently we don't support delete and void\r\nconst OPERATORS = \"...,.,===,==,+,!==,!=,!,||,&&,>=,>,<=,<,?,-,*,/,%,typeof ,=>,=,;,in ,new ,|,&,^,~\".split(\",\");\r\nlet tokenizeString = function (expr) {\r\n    let s = expr[0];\r\n    let start = s;\r\n    if (s !== \"'\" && s !== '\"' && s !== \"`\") {\r\n        return false;\r\n    }\r\n    let i = 1;\r\n    let cur;\r\n    while (expr[i] && expr[i] !== start) {\r\n        cur = expr[i];\r\n        s += cur;\r\n        if (cur === \"\\\\\") {\r\n            i++;\r\n            cur = expr[i];\r\n            if (!cur) {\r\n                throw new OwlError(\"Invalid expression\");\r\n            }\r\n            s += cur;\r\n        }\r\n        i++;\r\n    }\r\n    if (expr[i] !== start) {\r\n        throw new OwlError(\"Invalid expression\");\r\n    }\r\n    s += start;\r\n    if (start === \"`\") {\r\n        return {\r\n            type: \"TEMPLATE_STRING\",\r\n            value: s,\r\n            replace(replacer) {\r\n                return s.replace(/\\$\\{(.*?)\\}/g, (match, group) => {\r\n                    return \"${\" + replacer(group) + \"}\";\r\n                });\r\n            },\r\n        };\r\n    }\r\n    return { type: \"VALUE\", value: s };\r\n};\r\nlet tokenizeNumber = function (expr) {\r\n    let s = expr[0];\r\n    if (s && s.match(/[0-9]/)) {\r\n        let i = 1;\r\n        while (expr[i] && expr[i].match(/[0-9]|\\./)) {\r\n            s += expr[i];\r\n            i++;\r\n        }\r\n        return { type: \"VALUE\", value: s };\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n};\r\nlet tokenizeSymbol = function (expr) {\r\n    let s = expr[0];\r\n    if (s && s.match(/[a-zA-Z_\\$]/)) {\r\n        let i = 1;\r\n        while (expr[i] && expr[i].match(/\\w/)) {\r\n            s += expr[i];\r\n            i++;\r\n        }\r\n        if (s in WORD_REPLACEMENT) {\r\n            return { type: \"OPERATOR\", value: WORD_REPLACEMENT[s], size: s.length };\r\n        }\r\n        return { type: \"SYMBOL\", value: s };\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n};\r\nconst tokenizeStatic = function (expr) {\r\n    const char = expr[0];\r\n    if (char && char in STATIC_TOKEN_MAP) {\r\n        return { type: STATIC_TOKEN_MAP[char], value: char };\r\n    }\r\n    return false;\r\n};\r\nconst tokenizeOperator = function (expr) {\r\n    for (let op of OPERATORS) {\r\n        if (expr.startsWith(op)) {\r\n            return { type: \"OPERATOR\", value: op };\r\n        }\r\n    }\r\n    return false;\r\n};\r\nconst TOKENIZERS = [\r\n    tokenizeString,\r\n    tokenizeNumber,\r\n    tokenizeOperator,\r\n    tokenizeSymbol,\r\n    tokenizeStatic,\r\n];\r\n/**\r\n * Convert a javascript expression (as a string) into a list of tokens. For\r\n * example: `tokenize(\"1 + b\")` will return:\r\n * ```js\r\n *  [\r\n *   {type: \"VALUE\", value: \"1\"},\r\n *   {type: \"OPERATOR\", value: \"+\"},\r\n *   {type: \"SYMBOL\", value: \"b\"}\r\n * ]\r\n * ```\r\n */\r\nfunction tokenize(expr) {\r\n    const result = [];\r\n    let token = true;\r\n    let error;\r\n    let current = expr;\r\n    try {\r\n        while (token) {\r\n            current = current.trim();\r\n            if (current) {\r\n                for (let tokenizer of TOKENIZERS) {\r\n                    token = tokenizer(current);\r\n                    if (token) {\r\n                        result.push(token);\r\n                        current = current.slice(token.size || token.value.length);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                token = false;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        error = e; // Silence all errors and throw a generic error below\r\n    }\r\n    if (current.length || error) {\r\n        throw new OwlError(`Tokenizer error: could not tokenize \\`${expr}\\``);\r\n    }\r\n    return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n// Expression \"evaluator\"\r\n//------------------------------------------------------------------------------\r\nconst isLeftSeparator = (token) => token && (token.type === \"LEFT_BRACE\" || token.type === \"COMMA\");\r\nconst isRightSeparator = (token) => token && (token.type === \"RIGHT_BRACE\" || token.type === \"COMMA\");\r\n/**\r\n * This is the main function exported by this file. This is the code that will\r\n * process an expression (given as a string) and returns another expression with\r\n * proper lookups in the context.\r\n *\r\n * Usually, this kind of code would be very simple to do if we had an AST (so,\r\n * if we had a javascript parser), since then, we would only need to find the\r\n * variables and replace them.  However, a parser is more complicated, and there\r\n * are no standard builtin parser API.\r\n *\r\n * Since this method is applied to simple javasript expressions, and the work to\r\n * be done is actually quite simple, we actually can get away with not using a\r\n * parser, which helps with the code size.\r\n *\r\n * Here is the heuristic used by this method to determine if a token is a\r\n * variable:\r\n * - by default, all symbols are considered a variable\r\n * - unless the previous token is a dot (in that case, this is a property: `a.b`)\r\n * - or if the previous token is a left brace or a comma, and the next token is\r\n *   a colon (in that case, this is an object key: `{a: b}`)\r\n *\r\n * Some specific code is also required to support arrow functions. If we detect\r\n * the arrow operator, then we add the current (or some previous tokens) token to\r\n * the list of variables so it does not get replaced by a lookup in the context\r\n */\r\nfunction compileExprToArray(expr) {\r\n    const localVars = new Set();\r\n    const tokens = tokenize(expr);\r\n    let i = 0;\r\n    let stack = []; // to track last opening (, [ or {\r\n    while (i < tokens.length) {\r\n        let token = tokens[i];\r\n        let prevToken = tokens[i - 1];\r\n        let nextToken = tokens[i + 1];\r\n        let groupType = stack[stack.length - 1];\r\n        switch (token.type) {\r\n            case \"LEFT_BRACE\":\r\n            case \"LEFT_BRACKET\":\r\n            case \"LEFT_PAREN\":\r\n                stack.push(token.type);\r\n                break;\r\n            case \"RIGHT_BRACE\":\r\n            case \"RIGHT_BRACKET\":\r\n            case \"RIGHT_PAREN\":\r\n                stack.pop();\r\n        }\r\n        let isVar = token.type === \"SYMBOL\" && !RESERVED_WORDS.includes(token.value);\r\n        if (token.type === \"SYMBOL\" && !RESERVED_WORDS.includes(token.value)) {\r\n            if (prevToken) {\r\n                // normalize missing tokens: {a} should be equivalent to {a:a}\r\n                if (groupType === \"LEFT_BRACE\" &&\r\n                    isLeftSeparator(prevToken) &&\r\n                    isRightSeparator(nextToken)) {\r\n                    tokens.splice(i + 1, 0, { type: \"COLON\", value: \":\" }, { ...token });\r\n                    nextToken = tokens[i + 1];\r\n                }\r\n                if (prevToken.type === \"OPERATOR\" && prevToken.value === \".\") {\r\n                    isVar = false;\r\n                }\r\n                else if (prevToken.type === \"LEFT_BRACE\" || prevToken.type === \"COMMA\") {\r\n                    if (nextToken && nextToken.type === \"COLON\") {\r\n                        isVar = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (token.type === \"TEMPLATE_STRING\") {\r\n            token.value = token.replace((expr) => compileExpr(expr));\r\n        }\r\n        if (nextToken && nextToken.type === \"OPERATOR\" && nextToken.value === \"=>\") {\r\n            if (token.type === \"RIGHT_PAREN\") {\r\n                let j = i - 1;\r\n                while (j > 0 && tokens[j].type !== \"LEFT_PAREN\") {\r\n                    if (tokens[j].type === \"SYMBOL\" && tokens[j].originalValue) {\r\n                        tokens[j].value = tokens[j].originalValue;\r\n                        localVars.add(tokens[j].value); //] = { id: tokens[j].value, expr: tokens[j].value };\r\n                    }\r\n                    j--;\r\n                }\r\n            }\r\n            else {\r\n                localVars.add(token.value); //] = { id: token.value, expr: token.value };\r\n            }\r\n        }\r\n        if (isVar) {\r\n            token.varName = token.value;\r\n            if (!localVars.has(token.value)) {\r\n                token.originalValue = token.value;\r\n                token.value = `ctx['${token.value}']`;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n    // Mark all variables that have been used locally.\r\n    // This assumes the expression has only one scope (incorrect but \"good enough for now\")\r\n    for (const token of tokens) {\r\n        if (token.type === \"SYMBOL\" && token.varName && localVars.has(token.value)) {\r\n            token.originalValue = token.value;\r\n            token.value = `_${token.value}`;\r\n            token.isLocal = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n// Leading spaces are trimmed during tokenization, so they need to be added back for some values\r\nconst paddedValues = new Map([[\"in \", \" in \"]]);\r\nfunction compileExpr(expr) {\r\n    return compileExprToArray(expr)\r\n        .map((t) => paddedValues.get(t.value) || t.value)\r\n        .join(\"\");\r\n}\r\nconst INTERP_REGEXP = /\\{\\{.*?\\}\\}|\\#\\{.*?\\}/g;\r\nfunction replaceDynamicParts(s, replacer) {\r\n    let matches = s.match(INTERP_REGEXP);\r\n    if (matches && matches[0].length === s.length) {\r\n        return `(${replacer(s.slice(2, matches[0][0] === \"{\" ? -2 : -1))})`;\r\n    }\r\n    let r = s.replace(INTERP_REGEXP, (s) => \"${\" + replacer(s.slice(2, s[0] === \"{\" ? -2 : -1)) + \"}\");\r\n    return \"`\" + r + \"`\";\r\n}\r\nfunction interpolate(s) {\r\n    return replaceDynamicParts(s, compileExpr);\r\n}\n\nconst whitespaceRE = /\\s+/g;\r\n// using a non-html document so that <inner/outer>HTML serializes as XML instead\r\n// of HTML (as we will parse it as xml later)\r\nconst xmlDoc = document.implementation.createDocument(null, null, null);\r\nconst MODS = new Set([\"stop\", \"capture\", \"prevent\", \"self\", \"synthetic\"]);\r\nlet nextDataIds = {};\r\nfunction generateId(prefix = \"\") {\r\n    nextDataIds[prefix] = (nextDataIds[prefix] || 0) + 1;\r\n    return prefix + nextDataIds[prefix];\r\n}\r\nfunction isProp(tag, key) {\r\n    switch (tag) {\r\n        case \"input\":\r\n            return (key === \"checked\" ||\r\n                key === \"indeterminate\" ||\r\n                key === \"value\" ||\r\n                key === \"readonly\" ||\r\n                key === \"readOnly\" ||\r\n                key === \"disabled\");\r\n        case \"option\":\r\n            return key === \"selected\" || key === \"disabled\";\r\n        case \"textarea\":\r\n            return key === \"value\" || key === \"readonly\" || key === \"readOnly\" || key === \"disabled\";\r\n        case \"select\":\r\n            return key === \"value\" || key === \"disabled\";\r\n        case \"button\":\r\n        case \"optgroup\":\r\n            return key === \"disabled\";\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns a template literal that evaluates to str. You can add interpolation\r\n * sigils into the string if required\r\n */\r\nfunction toStringExpression(str) {\r\n    return `\\`${str.replace(/\\\\/g, \"\\\\\\\\\").replace(/`/g, \"\\\\`\").replace(/\\$\\{/, \"\\\\${\")}\\``;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// BlockDescription\r\n// -----------------------------------------------------------------------------\r\nclass BlockDescription {\r\n    constructor(target, type) {\r\n        this.dynamicTagName = null;\r\n        this.isRoot = false;\r\n        this.hasDynamicChildren = false;\r\n        this.children = [];\r\n        this.data = [];\r\n        this.childNumber = 0;\r\n        this.parentVar = \"\";\r\n        this.id = BlockDescription.nextBlockId++;\r\n        this.varName = \"b\" + this.id;\r\n        this.blockName = \"block\" + this.id;\r\n        this.target = target;\r\n        this.type = type;\r\n    }\r\n    insertData(str, prefix = \"d\") {\r\n        const id = generateId(prefix);\r\n        this.target.addLine(`let ${id} = ${str};`);\r\n        return this.data.push(id) - 1;\r\n    }\r\n    insert(dom) {\r\n        if (this.currentDom) {\r\n            this.currentDom.appendChild(dom);\r\n        }\r\n        else {\r\n            this.dom = dom;\r\n        }\r\n    }\r\n    generateExpr(expr) {\r\n        if (this.type === \"block\") {\r\n            const hasChildren = this.children.length;\r\n            let params = this.data.length ? `[${this.data.join(\", \")}]` : hasChildren ? \"[]\" : \"\";\r\n            if (hasChildren) {\r\n                params += \", [\" + this.children.map((c) => c.varName).join(\", \") + \"]\";\r\n            }\r\n            if (this.dynamicTagName) {\r\n                return `toggler(${this.dynamicTagName}, ${this.blockName}(${this.dynamicTagName})(${params}))`;\r\n            }\r\n            return `${this.blockName}(${params})`;\r\n        }\r\n        else if (this.type === \"list\") {\r\n            return `list(c_block${this.id})`;\r\n        }\r\n        return expr;\r\n    }\r\n    asXmlString() {\r\n        // Can't use outerHTML on text/comment nodes\r\n        // append dom to any element and use innerHTML instead\r\n        const t = xmlDoc.createElement(\"t\");\r\n        t.appendChild(this.dom);\r\n        return t.innerHTML;\r\n    }\r\n}\r\nBlockDescription.nextBlockId = 1;\r\nfunction createContext(parentCtx, params) {\r\n    return Object.assign({\r\n        block: null,\r\n        index: 0,\r\n        forceNewBlock: true,\r\n        translate: parentCtx.translate,\r\n        translationCtx: parentCtx.translationCtx,\r\n        tKeyExpr: null,\r\n        nameSpace: parentCtx.nameSpace,\r\n        tModelSelectedExpr: parentCtx.tModelSelectedExpr,\r\n    }, params);\r\n}\r\nclass CodeTarget {\r\n    constructor(name, on) {\r\n        this.indentLevel = 0;\r\n        this.loopLevel = 0;\r\n        this.code = [];\r\n        this.hasRoot = false;\r\n        this.hasCache = false;\r\n        this.shouldProtectScope = false;\r\n        this.hasRefWrapper = false;\r\n        this.name = name;\r\n        this.on = on || null;\r\n    }\r\n    addLine(line, idx) {\r\n        const prefix = new Array(this.indentLevel + 2).join(\"  \");\r\n        if (idx === undefined) {\r\n            this.code.push(prefix + line);\r\n        }\r\n        else {\r\n            this.code.splice(idx, 0, prefix + line);\r\n        }\r\n    }\r\n    generateCode() {\r\n        let result = [];\r\n        result.push(`function ${this.name}(ctx, node, key = \"\") {`);\r\n        if (this.shouldProtectScope) {\r\n            result.push(`  ctx = Object.create(ctx);`);\r\n            result.push(`  ctx[isBoundary] = 1`);\r\n        }\r\n        if (this.hasRefWrapper) {\r\n            result.push(`  let refWrapper = makeRefWrapper(this.__owl__);`);\r\n        }\r\n        if (this.hasCache) {\r\n            result.push(`  let cache = ctx.cache || {};`);\r\n            result.push(`  let nextCache = ctx.cache = {};`);\r\n        }\r\n        for (let line of this.code) {\r\n            result.push(line);\r\n        }\r\n        if (!this.hasRoot) {\r\n            result.push(`return text('');`);\r\n        }\r\n        result.push(`}`);\r\n        return result.join(\"\\n  \");\r\n    }\r\n    currentKey(ctx) {\r\n        let key = this.loopLevel ? `key${this.loopLevel}` : \"key\";\r\n        if (ctx.tKeyExpr) {\r\n            key = `${ctx.tKeyExpr} + ${key}`;\r\n        }\r\n        return key;\r\n    }\r\n}\r\nconst TRANSLATABLE_ATTRS = [\r\n    \"alt\",\r\n    \"aria-label\",\r\n    \"aria-placeholder\",\r\n    \"aria-roledescription\",\r\n    \"aria-valuetext\",\r\n    \"label\",\r\n    \"placeholder\",\r\n    \"title\",\r\n];\r\nconst translationRE = /^(\\s*)([\\s\\S]+?)(\\s*)$/;\r\nclass CodeGenerator {\r\n    constructor(ast, options) {\r\n        this.blocks = [];\r\n        this.nextBlockId = 1;\r\n        this.isDebug = false;\r\n        this.targets = [];\r\n        this.target = new CodeTarget(\"template\");\r\n        this.translatableAttributes = TRANSLATABLE_ATTRS;\r\n        this.staticDefs = [];\r\n        this.slotNames = new Set();\r\n        this.helpers = new Set();\r\n        this.translateFn = options.translateFn || ((s) => s);\r\n        if (options.translatableAttributes) {\r\n            const attrs = new Set(TRANSLATABLE_ATTRS);\r\n            for (let attr of options.translatableAttributes) {\r\n                if (attr.startsWith(\"-\")) {\r\n                    attrs.delete(attr.slice(1));\r\n                }\r\n                else {\r\n                    attrs.add(attr);\r\n                }\r\n            }\r\n            this.translatableAttributes = [...attrs];\r\n        }\r\n        this.hasSafeContext = options.hasSafeContext || false;\r\n        this.dev = options.dev || false;\r\n        this.ast = ast;\r\n        this.templateName = options.name;\r\n        if (options.hasGlobalValues) {\r\n            this.helpers.add(\"__globals__\");\r\n        }\r\n    }\r\n    generateCode() {\r\n        const ast = this.ast;\r\n        this.isDebug = ast.type === 12 /* TDebug */;\r\n        BlockDescription.nextBlockId = 1;\r\n        nextDataIds = {};\r\n        this.compileAST(ast, {\r\n            block: null,\r\n            index: 0,\r\n            forceNewBlock: false,\r\n            isLast: true,\r\n            translate: true,\r\n            translationCtx: \"\",\r\n            tKeyExpr: null,\r\n        });\r\n        // define blocks and utility functions\r\n        let mainCode = [`  let { text, createBlock, list, multi, html, toggler, comment } = bdom;`];\r\n        if (this.helpers.size) {\r\n            mainCode.push(`let { ${[...this.helpers].join(\", \")} } = helpers;`);\r\n        }\r\n        if (this.templateName) {\r\n            mainCode.push(`// Template name: \"${this.templateName}\"`);\r\n        }\r\n        for (let { id, expr } of this.staticDefs) {\r\n            mainCode.push(`const ${id} = ${expr};`);\r\n        }\r\n        // define all blocks\r\n        if (this.blocks.length) {\r\n            mainCode.push(``);\r\n            for (let block of this.blocks) {\r\n                if (block.dom) {\r\n                    let xmlString = toStringExpression(block.asXmlString());\r\n                    if (block.dynamicTagName) {\r\n                        xmlString = xmlString.replace(/^`<\\w+/, `\\`<\\${tag || '${block.dom.nodeName}'}`);\r\n                        xmlString = xmlString.replace(/\\w+>`$/, `\\${tag || '${block.dom.nodeName}'}>\\``);\r\n                        mainCode.push(`let ${block.blockName} = tag => createBlock(${xmlString});`);\r\n                    }\r\n                    else {\r\n                        mainCode.push(`let ${block.blockName} = createBlock(${xmlString});`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // define all slots/defaultcontent function\r\n        if (this.targets.length) {\r\n            for (let fn of this.targets) {\r\n                mainCode.push(\"\");\r\n                mainCode = mainCode.concat(fn.generateCode());\r\n            }\r\n        }\r\n        // generate main code\r\n        mainCode.push(\"\");\r\n        mainCode = mainCode.concat(\"return \" + this.target.generateCode());\r\n        const code = mainCode.join(\"\\n  \");\r\n        if (this.isDebug) {\r\n            const msg = `[Owl Debug]\\n${code}`;\r\n            console.log(msg);\r\n        }\r\n        return code;\r\n    }\r\n    compileInNewTarget(prefix, ast, ctx, on) {\r\n        const name = generateId(prefix);\r\n        const initialTarget = this.target;\r\n        const target = new CodeTarget(name, on);\r\n        this.targets.push(target);\r\n        this.target = target;\r\n        this.compileAST(ast, createContext(ctx));\r\n        this.target = initialTarget;\r\n        return name;\r\n    }\r\n    addLine(line, idx) {\r\n        this.target.addLine(line, idx);\r\n    }\r\n    define(varName, expr) {\r\n        this.addLine(`const ${varName} = ${expr};`);\r\n    }\r\n    insertAnchor(block, index = block.children.length) {\r\n        const tag = `block-child-${index}`;\r\n        const anchor = xmlDoc.createElement(tag);\r\n        block.insert(anchor);\r\n    }\r\n    createBlock(parentBlock, type, ctx) {\r\n        const hasRoot = this.target.hasRoot;\r\n        const block = new BlockDescription(this.target, type);\r\n        if (!hasRoot) {\r\n            this.target.hasRoot = true;\r\n            block.isRoot = true;\r\n        }\r\n        if (parentBlock) {\r\n            parentBlock.children.push(block);\r\n            if (parentBlock.type === \"list\") {\r\n                block.parentVar = `c_block${parentBlock.id}`;\r\n            }\r\n        }\r\n        return block;\r\n    }\r\n    insertBlock(expression, block, ctx) {\r\n        let blockExpr = block.generateExpr(expression);\r\n        if (block.parentVar) {\r\n            let key = this.target.currentKey(ctx);\r\n            this.helpers.add(\"withKey\");\r\n            this.addLine(`${block.parentVar}[${ctx.index}] = withKey(${blockExpr}, ${key});`);\r\n            return;\r\n        }\r\n        if (ctx.tKeyExpr) {\r\n            blockExpr = `toggler(${ctx.tKeyExpr}, ${blockExpr})`;\r\n        }\r\n        if (block.isRoot) {\r\n            if (this.target.on) {\r\n                blockExpr = this.wrapWithEventCatcher(blockExpr, this.target.on);\r\n            }\r\n            this.addLine(`return ${blockExpr};`);\r\n        }\r\n        else {\r\n            this.define(block.varName, blockExpr);\r\n        }\r\n    }\r\n    /**\r\n     * Captures variables that are used inside of an expression. This is useful\r\n     * because in compiled code, almost all variables are accessed through the ctx\r\n     * object. In the case of functions, that lookup in the context can be delayed\r\n     * which can cause issues if the value has changed since the function was\r\n     * defined.\r\n     *\r\n     * @param expr the expression to capture\r\n     * @param forceCapture whether the expression should capture its scope even if\r\n     *  it doesn't contain a function. Useful when the expression will be used as\r\n     *  a function body.\r\n     * @returns a new expression that uses the captured values\r\n     */\r\n    captureExpression(expr, forceCapture = false) {\r\n        if (!forceCapture && !expr.includes(\"=>\")) {\r\n            return compileExpr(expr);\r\n        }\r\n        const tokens = compileExprToArray(expr);\r\n        const mapping = new Map();\r\n        return tokens\r\n            .map((tok) => {\r\n            if (tok.varName && !tok.isLocal) {\r\n                if (!mapping.has(tok.varName)) {\r\n                    const varId = generateId(\"v\");\r\n                    mapping.set(tok.varName, varId);\r\n                    this.define(varId, tok.value);\r\n                }\r\n                tok.value = mapping.get(tok.varName);\r\n            }\r\n            return tok.value;\r\n        })\r\n            .join(\"\");\r\n    }\r\n    translate(str, translationCtx) {\r\n        const match = translationRE.exec(str);\r\n        return match[1] + this.translateFn(match[2], translationCtx) + match[3];\r\n    }\r\n    /**\r\n     * @returns the newly created block name, if any\r\n     */\r\n    compileAST(ast, ctx) {\r\n        switch (ast.type) {\r\n            case 1 /* Comment */:\r\n                return this.compileComment(ast, ctx);\r\n            case 0 /* Text */:\r\n                return this.compileText(ast, ctx);\r\n            case 2 /* DomNode */:\r\n                return this.compileTDomNode(ast, ctx);\r\n            case 4 /* TEsc */:\r\n                return this.compileTEsc(ast, ctx);\r\n            case 8 /* TOut */:\r\n                return this.compileTOut(ast, ctx);\r\n            case 5 /* TIf */:\r\n                return this.compileTIf(ast, ctx);\r\n            case 9 /* TForEach */:\r\n                return this.compileTForeach(ast, ctx);\r\n            case 10 /* TKey */:\r\n                return this.compileTKey(ast, ctx);\r\n            case 3 /* Multi */:\r\n                return this.compileMulti(ast, ctx);\r\n            case 7 /* TCall */:\r\n                return this.compileTCall(ast, ctx);\r\n            case 15 /* TCallBlock */:\r\n                return this.compileTCallBlock(ast, ctx);\r\n            case 6 /* TSet */:\r\n                return this.compileTSet(ast, ctx);\r\n            case 11 /* TComponent */:\r\n                return this.compileComponent(ast, ctx);\r\n            case 12 /* TDebug */:\r\n                return this.compileDebug(ast, ctx);\r\n            case 13 /* TLog */:\r\n                return this.compileLog(ast, ctx);\r\n            case 14 /* TSlot */:\r\n                return this.compileTSlot(ast, ctx);\r\n            case 16 /* TTranslation */:\r\n                return this.compileTTranslation(ast, ctx);\r\n            case 17 /* TTranslationContext */:\r\n                return this.compileTTranslationContext(ast, ctx);\r\n            case 18 /* TPortal */:\r\n                return this.compileTPortal(ast, ctx);\r\n        }\r\n    }\r\n    compileDebug(ast, ctx) {\r\n        this.addLine(`debugger;`);\r\n        if (ast.content) {\r\n            return this.compileAST(ast.content, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    compileLog(ast, ctx) {\r\n        this.addLine(`console.log(${compileExpr(ast.expr)});`);\r\n        if (ast.content) {\r\n            return this.compileAST(ast.content, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    compileComment(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        const isNewBlock = !block || forceNewBlock;\r\n        if (isNewBlock) {\r\n            block = this.createBlock(block, \"comment\", ctx);\r\n            this.insertBlock(`comment(${toStringExpression(ast.value)})`, block, {\r\n                ...ctx,\r\n                forceNewBlock: forceNewBlock && !block,\r\n            });\r\n        }\r\n        else {\r\n            const text = xmlDoc.createComment(ast.value);\r\n            block.insert(text);\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileText(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        let value = ast.value;\r\n        if (value && ctx.translate !== false) {\r\n            value = this.translate(value, ctx.translationCtx);\r\n        }\r\n        if (!ctx.inPreTag) {\r\n            value = value.replace(whitespaceRE, \" \");\r\n        }\r\n        if (!block || forceNewBlock) {\r\n            block = this.createBlock(block, \"text\", ctx);\r\n            this.insertBlock(`text(${toStringExpression(value)})`, block, {\r\n                ...ctx,\r\n                forceNewBlock: forceNewBlock && !block,\r\n            });\r\n        }\r\n        else {\r\n            const createFn = ast.type === 0 /* Text */ ? xmlDoc.createTextNode : xmlDoc.createComment;\r\n            block.insert(createFn.call(xmlDoc, value));\r\n        }\r\n        return block.varName;\r\n    }\r\n    generateHandlerCode(rawEvent, handler) {\r\n        const modifiers = rawEvent\r\n            .split(\".\")\r\n            .slice(1)\r\n            .map((m) => {\r\n            if (!MODS.has(m)) {\r\n                throw new OwlError(`Unknown event modifier: '${m}'`);\r\n            }\r\n            return `\"${m}\"`;\r\n        });\r\n        let modifiersCode = \"\";\r\n        if (modifiers.length) {\r\n            modifiersCode = `${modifiers.join(\",\")}, `;\r\n        }\r\n        return `[${modifiersCode}${this.captureExpression(handler)}, ctx]`;\r\n    }\r\n    compileTDomNode(ast, ctx) {\r\n        var _a;\r\n        let { block, forceNewBlock } = ctx;\r\n        const isNewBlock = !block || forceNewBlock || ast.dynamicTag !== null || ast.ns;\r\n        let codeIdx = this.target.code.length;\r\n        if (isNewBlock) {\r\n            if ((ast.dynamicTag || ctx.tKeyExpr || ast.ns) && ctx.block) {\r\n                this.insertAnchor(ctx.block);\r\n            }\r\n            block = this.createBlock(block, \"block\", ctx);\r\n            this.blocks.push(block);\r\n            if (ast.dynamicTag) {\r\n                const tagExpr = generateId(\"tag\");\r\n                this.define(tagExpr, compileExpr(ast.dynamicTag));\r\n                block.dynamicTagName = tagExpr;\r\n            }\r\n        }\r\n        // attributes\r\n        const attrs = {};\r\n        for (let key in ast.attrs) {\r\n            let expr, attrName;\r\n            if (key.startsWith(\"t-attf\")) {\r\n                expr = interpolate(ast.attrs[key]);\r\n                const idx = block.insertData(expr, \"attr\");\r\n                attrName = key.slice(7);\r\n                attrs[\"block-attribute-\" + idx] = attrName;\r\n            }\r\n            else if (key.startsWith(\"t-att\")) {\r\n                attrName = key === \"t-att\" ? null : key.slice(6);\r\n                expr = compileExpr(ast.attrs[key]);\r\n                if (attrName && isProp(ast.tag, attrName)) {\r\n                    if (attrName === \"readonly\") {\r\n                        // the property has a different name than the attribute\r\n                        attrName = \"readOnly\";\r\n                    }\r\n                    // we force a new string or new boolean to bypass the equality check in blockdom when patching same value\r\n                    if (attrName === \"value\") {\r\n                        // When the expression is falsy (except 0), fall back to an empty string\r\n                        expr = `new String((${expr}) === 0 ? 0 : ((${expr}) || \"\"))`;\r\n                    }\r\n                    else {\r\n                        expr = `new Boolean(${expr})`;\r\n                    }\r\n                    const idx = block.insertData(expr, \"prop\");\r\n                    attrs[`block-property-${idx}`] = attrName;\r\n                }\r\n                else {\r\n                    const idx = block.insertData(expr, \"attr\");\r\n                    if (key === \"t-att\") {\r\n                        attrs[`block-attributes`] = String(idx);\r\n                    }\r\n                    else {\r\n                        attrs[`block-attribute-${idx}`] = attrName;\r\n                    }\r\n                }\r\n            }\r\n            else if (this.translatableAttributes.includes(key)) {\r\n                const attrTranslationCtx = ((_a = ast.attrsTranslationCtx) === null || _a === void 0 ? void 0 : _a[key]) || ctx.translationCtx;\r\n                attrs[key] = this.translateFn(ast.attrs[key], attrTranslationCtx);\r\n            }\r\n            else {\r\n                expr = `\"${ast.attrs[key]}\"`;\r\n                attrName = key;\r\n                attrs[key] = ast.attrs[key];\r\n            }\r\n            if (attrName === \"value\" && ctx.tModelSelectedExpr) {\r\n                let selectedId = block.insertData(`${ctx.tModelSelectedExpr} === ${expr}`, \"attr\");\r\n                attrs[`block-attribute-${selectedId}`] = \"selected\";\r\n            }\r\n        }\r\n        // t-model\r\n        let tModelSelectedExpr;\r\n        if (ast.model) {\r\n            const { hasDynamicChildren, baseExpr, expr, eventType, shouldNumberize, shouldTrim, targetAttr, specialInitTargetAttr, } = ast.model;\r\n            const baseExpression = compileExpr(baseExpr);\r\n            const bExprId = generateId(\"bExpr\");\r\n            this.define(bExprId, baseExpression);\r\n            const expression = compileExpr(expr);\r\n            const exprId = generateId(\"expr\");\r\n            this.define(exprId, expression);\r\n            const fullExpression = `${bExprId}[${exprId}]`;\r\n            let idx;\r\n            if (specialInitTargetAttr) {\r\n                let targetExpr = targetAttr in attrs && `'${attrs[targetAttr]}'`;\r\n                if (!targetExpr && ast.attrs) {\r\n                    // look at the dynamic attribute counterpart\r\n                    const dynamicTgExpr = ast.attrs[`t-att-${targetAttr}`];\r\n                    if (dynamicTgExpr) {\r\n                        targetExpr = compileExpr(dynamicTgExpr);\r\n                    }\r\n                }\r\n                idx = block.insertData(`${fullExpression} === ${targetExpr}`, \"prop\");\r\n                attrs[`block-property-${idx}`] = specialInitTargetAttr;\r\n            }\r\n            else if (hasDynamicChildren) {\r\n                const bValueId = generateId(\"bValue\");\r\n                tModelSelectedExpr = `${bValueId}`;\r\n                this.define(tModelSelectedExpr, fullExpression);\r\n            }\r\n            else {\r\n                idx = block.insertData(`${fullExpression}`, \"prop\");\r\n                attrs[`block-property-${idx}`] = targetAttr;\r\n            }\r\n            this.helpers.add(\"toNumber\");\r\n            let valueCode = `ev.target.${targetAttr}`;\r\n            valueCode = shouldTrim ? `${valueCode}.trim()` : valueCode;\r\n            valueCode = shouldNumberize ? `toNumber(${valueCode})` : valueCode;\r\n            const handler = `[(ev) => { ${fullExpression} = ${valueCode}; }]`;\r\n            idx = block.insertData(handler, \"hdlr\");\r\n            attrs[`block-handler-${idx}`] = eventType;\r\n        }\r\n        // event handlers\r\n        for (let ev in ast.on) {\r\n            const name = this.generateHandlerCode(ev, ast.on[ev]);\r\n            const idx = block.insertData(name, \"hdlr\");\r\n            attrs[`block-handler-${idx}`] = ev;\r\n        }\r\n        // t-ref\r\n        if (ast.ref) {\r\n            if (this.dev) {\r\n                this.helpers.add(\"makeRefWrapper\");\r\n                this.target.hasRefWrapper = true;\r\n            }\r\n            const isDynamic = INTERP_REGEXP.test(ast.ref);\r\n            let name = `\\`${ast.ref}\\``;\r\n            if (isDynamic) {\r\n                name = replaceDynamicParts(ast.ref, (expr) => this.captureExpression(expr, true));\r\n            }\r\n            let setRefStr = `(el) => this.__owl__.setRef((${name}), el)`;\r\n            if (this.dev) {\r\n                setRefStr = `refWrapper(${name}, ${setRefStr})`;\r\n            }\r\n            const idx = block.insertData(setRefStr, \"ref\");\r\n            attrs[\"block-ref\"] = String(idx);\r\n        }\r\n        const nameSpace = ast.ns || ctx.nameSpace;\r\n        const dom = nameSpace\r\n            ? xmlDoc.createElementNS(nameSpace, ast.tag)\r\n            : xmlDoc.createElement(ast.tag);\r\n        for (const [attr, val] of Object.entries(attrs)) {\r\n            if (!(attr === \"class\" && val === \"\")) {\r\n                dom.setAttribute(attr, val);\r\n            }\r\n        }\r\n        block.insert(dom);\r\n        if (ast.content.length) {\r\n            const initialDom = block.currentDom;\r\n            block.currentDom = dom;\r\n            const children = ast.content;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = ast.content[i];\r\n                const subCtx = createContext(ctx, {\r\n                    block,\r\n                    index: block.childNumber,\r\n                    forceNewBlock: false,\r\n                    isLast: ctx.isLast && i === children.length - 1,\r\n                    tKeyExpr: ctx.tKeyExpr,\r\n                    nameSpace,\r\n                    tModelSelectedExpr,\r\n                    inPreTag: ctx.inPreTag || ast.tag === \"pre\",\r\n                });\r\n                this.compileAST(child, subCtx);\r\n            }\r\n            block.currentDom = initialDom;\r\n        }\r\n        if (isNewBlock) {\r\n            this.insertBlock(`${block.blockName}(ddd)`, block, ctx);\r\n            // may need to rewrite code!\r\n            if (block.children.length && block.hasDynamicChildren) {\r\n                const code = this.target.code;\r\n                const children = block.children.slice();\r\n                let current = children.shift();\r\n                for (let i = codeIdx; i < code.length; i++) {\r\n                    if (code[i].trimStart().startsWith(`const ${current.varName} `)) {\r\n                        code[i] = code[i].replace(`const ${current.varName}`, current.varName);\r\n                        current = children.shift();\r\n                        if (!current)\r\n                            break;\r\n                    }\r\n                }\r\n                this.addLine(`let ${block.children.map((c) => c.varName).join(\", \")};`, codeIdx);\r\n            }\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileTEsc(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        let expr;\r\n        if (ast.expr === \"0\") {\r\n            this.helpers.add(\"zero\");\r\n            expr = `ctx[zero]`;\r\n        }\r\n        else {\r\n            expr = compileExpr(ast.expr);\r\n            if (ast.defaultValue) {\r\n                this.helpers.add(\"withDefault\");\r\n                // FIXME: defaultValue is not translated\r\n                expr = `withDefault(${expr}, ${toStringExpression(ast.defaultValue)})`;\r\n            }\r\n        }\r\n        if (!block || forceNewBlock) {\r\n            block = this.createBlock(block, \"text\", ctx);\r\n            this.insertBlock(`text(${expr})`, block, { ...ctx, forceNewBlock: forceNewBlock && !block });\r\n        }\r\n        else {\r\n            const idx = block.insertData(expr, \"txt\");\r\n            const text = xmlDoc.createElement(`block-text-${idx}`);\r\n            block.insert(text);\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileTOut(ast, ctx) {\r\n        let { block } = ctx;\r\n        if (block) {\r\n            this.insertAnchor(block);\r\n        }\r\n        block = this.createBlock(block, \"html\", ctx);\r\n        let blockStr;\r\n        if (ast.expr === \"0\") {\r\n            this.helpers.add(\"zero\");\r\n            blockStr = `ctx[zero]`;\r\n        }\r\n        else if (ast.body) {\r\n            let bodyValue = null;\r\n            bodyValue = BlockDescription.nextBlockId;\r\n            const subCtx = createContext(ctx);\r\n            this.compileAST({ type: 3 /* Multi */, content: ast.body }, subCtx);\r\n            this.helpers.add(\"safeOutput\");\r\n            blockStr = `safeOutput(${compileExpr(ast.expr)}, b${bodyValue})`;\r\n        }\r\n        else {\r\n            this.helpers.add(\"safeOutput\");\r\n            blockStr = `safeOutput(${compileExpr(ast.expr)})`;\r\n        }\r\n        this.insertBlock(blockStr, block, ctx);\r\n        return block.varName;\r\n    }\r\n    compileTIfBranch(content, block, ctx) {\r\n        this.target.indentLevel++;\r\n        let childN = block.children.length;\r\n        this.compileAST(content, createContext(ctx, { block, index: ctx.index }));\r\n        if (block.children.length > childN) {\r\n            // we have some content => need to insert an anchor at correct index\r\n            this.insertAnchor(block, childN);\r\n        }\r\n        this.target.indentLevel--;\r\n    }\r\n    compileTIf(ast, ctx, nextNode) {\r\n        let { block, forceNewBlock } = ctx;\r\n        const codeIdx = this.target.code.length;\r\n        const isNewBlock = !block || (block.type !== \"multi\" && forceNewBlock);\r\n        if (block) {\r\n            block.hasDynamicChildren = true;\r\n        }\r\n        if (!block || (block.type !== \"multi\" && forceNewBlock)) {\r\n            block = this.createBlock(block, \"multi\", ctx);\r\n        }\r\n        this.addLine(`if (${compileExpr(ast.condition)}) {`);\r\n        this.compileTIfBranch(ast.content, block, ctx);\r\n        if (ast.tElif) {\r\n            for (let clause of ast.tElif) {\r\n                this.addLine(`} else if (${compileExpr(clause.condition)}) {`);\r\n                this.compileTIfBranch(clause.content, block, ctx);\r\n            }\r\n        }\r\n        if (ast.tElse) {\r\n            this.addLine(`} else {`);\r\n            this.compileTIfBranch(ast.tElse, block, ctx);\r\n        }\r\n        this.addLine(\"}\");\r\n        if (isNewBlock) {\r\n            // note: this part is duplicated from end of compiledomnode:\r\n            if (block.children.length) {\r\n                const code = this.target.code;\r\n                const children = block.children.slice();\r\n                let current = children.shift();\r\n                for (let i = codeIdx; i < code.length; i++) {\r\n                    if (code[i].trimStart().startsWith(`const ${current.varName} `)) {\r\n                        code[i] = code[i].replace(`const ${current.varName}`, current.varName);\r\n                        current = children.shift();\r\n                        if (!current)\r\n                            break;\r\n                    }\r\n                }\r\n                this.addLine(`let ${block.children.map((c) => c.varName).join(\", \")};`, codeIdx);\r\n            }\r\n            // note: this part is duplicated from end of compilemulti:\r\n            const args = block.children.map((c) => c.varName).join(\", \");\r\n            this.insertBlock(`multi([${args}])`, block, ctx);\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileTForeach(ast, ctx) {\r\n        let { block } = ctx;\r\n        if (block) {\r\n            this.insertAnchor(block);\r\n        }\r\n        block = this.createBlock(block, \"list\", ctx);\r\n        this.target.loopLevel++;\r\n        const loopVar = `i${this.target.loopLevel}`;\r\n        this.addLine(`ctx = Object.create(ctx);`);\r\n        const vals = `v_block${block.id}`;\r\n        const keys = `k_block${block.id}`;\r\n        const l = `l_block${block.id}`;\r\n        const c = `c_block${block.id}`;\r\n        this.helpers.add(\"prepareList\");\r\n        this.define(`[${keys}, ${vals}, ${l}, ${c}]`, `prepareList(${compileExpr(ast.collection)});`);\r\n        // Throw errors on duplicate keys in dev mode\r\n        if (this.dev) {\r\n            this.define(`keys${block.id}`, `new Set()`);\r\n        }\r\n        this.addLine(`for (let ${loopVar} = 0; ${loopVar} < ${l}; ${loopVar}++) {`);\r\n        this.target.indentLevel++;\r\n        this.addLine(`ctx[\\`${ast.elem}\\`] = ${keys}[${loopVar}];`);\r\n        if (!ast.hasNoFirst) {\r\n            this.addLine(`ctx[\\`${ast.elem}_first\\`] = ${loopVar} === 0;`);\r\n        }\r\n        if (!ast.hasNoLast) {\r\n            this.addLine(`ctx[\\`${ast.elem}_last\\`] = ${loopVar} === ${keys}.length - 1;`);\r\n        }\r\n        if (!ast.hasNoIndex) {\r\n            this.addLine(`ctx[\\`${ast.elem}_index\\`] = ${loopVar};`);\r\n        }\r\n        if (!ast.hasNoValue) {\r\n            this.addLine(`ctx[\\`${ast.elem}_value\\`] = ${vals}[${loopVar}];`);\r\n        }\r\n        this.define(`key${this.target.loopLevel}`, ast.key ? compileExpr(ast.key) : loopVar);\r\n        if (this.dev) {\r\n            // Throw error on duplicate keys in dev mode\r\n            this.helpers.add(\"OwlError\");\r\n            this.addLine(`if (keys${block.id}.has(String(key${this.target.loopLevel}))) { throw new OwlError(\\`Got duplicate key in t-foreach: \\${key${this.target.loopLevel}}\\`)}`);\r\n            this.addLine(`keys${block.id}.add(String(key${this.target.loopLevel}));`);\r\n        }\r\n        let id;\r\n        if (ast.memo) {\r\n            this.target.hasCache = true;\r\n            id = generateId();\r\n            this.define(`memo${id}`, compileExpr(ast.memo));\r\n            this.define(`vnode${id}`, `cache[key${this.target.loopLevel}];`);\r\n            this.addLine(`if (vnode${id}) {`);\r\n            this.target.indentLevel++;\r\n            this.addLine(`if (shallowEqual(vnode${id}.memo, memo${id})) {`);\r\n            this.target.indentLevel++;\r\n            this.addLine(`${c}[${loopVar}] = vnode${id};`);\r\n            this.addLine(`nextCache[key${this.target.loopLevel}] = vnode${id};`);\r\n            this.addLine(`continue;`);\r\n            this.target.indentLevel--;\r\n            this.addLine(\"}\");\r\n            this.target.indentLevel--;\r\n            this.addLine(\"}\");\r\n        }\r\n        const subCtx = createContext(ctx, { block, index: loopVar });\r\n        this.compileAST(ast.body, subCtx);\r\n        if (ast.memo) {\r\n            this.addLine(`nextCache[key${this.target.loopLevel}] = Object.assign(${c}[${loopVar}], {memo: memo${id}});`);\r\n        }\r\n        this.target.indentLevel--;\r\n        this.target.loopLevel--;\r\n        this.addLine(`}`);\r\n        if (!ctx.isLast) {\r\n            this.addLine(`ctx = ctx.__proto__;`);\r\n        }\r\n        this.insertBlock(\"l\", block, ctx);\r\n        return block.varName;\r\n    }\r\n    compileTKey(ast, ctx) {\r\n        const tKeyExpr = generateId(\"tKey_\");\r\n        this.define(tKeyExpr, compileExpr(ast.expr));\r\n        ctx = createContext(ctx, {\r\n            tKeyExpr,\r\n            block: ctx.block,\r\n            index: ctx.index,\r\n        });\r\n        return this.compileAST(ast.content, ctx);\r\n    }\r\n    compileMulti(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        const isNewBlock = !block || forceNewBlock;\r\n        let codeIdx = this.target.code.length;\r\n        if (isNewBlock) {\r\n            const n = ast.content.filter((c) => !c.hasNoRepresentation).length;\r\n            let result = null;\r\n            if (n <= 1) {\r\n                for (let child of ast.content) {\r\n                    const blockName = this.compileAST(child, ctx);\r\n                    result = result || blockName;\r\n                }\r\n                return result;\r\n            }\r\n            block = this.createBlock(block, \"multi\", ctx);\r\n        }\r\n        let index = 0;\r\n        for (let i = 0, l = ast.content.length; i < l; i++) {\r\n            const child = ast.content[i];\r\n            const forceNewBlock = !child.hasNoRepresentation;\r\n            const subCtx = createContext(ctx, {\r\n                block,\r\n                index,\r\n                forceNewBlock,\r\n                isLast: ctx.isLast && i === l - 1,\r\n            });\r\n            this.compileAST(child, subCtx);\r\n            if (forceNewBlock) {\r\n                index++;\r\n            }\r\n        }\r\n        if (isNewBlock) {\r\n            if (block.hasDynamicChildren && block.children.length) {\r\n                const code = this.target.code;\r\n                const children = block.children.slice();\r\n                let current = children.shift();\r\n                for (let i = codeIdx; i < code.length; i++) {\r\n                    if (code[i].trimStart().startsWith(`const ${current.varName} `)) {\r\n                        code[i] = code[i].replace(`const ${current.varName}`, current.varName);\r\n                        current = children.shift();\r\n                        if (!current)\r\n                            break;\r\n                    }\r\n                }\r\n                this.addLine(`let ${block.children.map((c) => c.varName).join(\", \")};`, codeIdx);\r\n            }\r\n            const args = block.children.map((c) => c.varName).join(\", \");\r\n            this.insertBlock(`multi([${args}])`, block, ctx);\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileTCall(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        let ctxVar = ctx.ctxVar || \"ctx\";\r\n        if (ast.context) {\r\n            ctxVar = generateId(\"ctx\");\r\n            this.addLine(`let ${ctxVar} = ${compileExpr(ast.context)};`);\r\n        }\r\n        const isDynamic = INTERP_REGEXP.test(ast.name);\r\n        const subTemplate = isDynamic ? interpolate(ast.name) : \"`\" + ast.name + \"`\";\r\n        if (block && !forceNewBlock) {\r\n            this.insertAnchor(block);\r\n        }\r\n        block = this.createBlock(block, \"multi\", ctx);\r\n        if (ast.body) {\r\n            this.addLine(`${ctxVar} = Object.create(${ctxVar});`);\r\n            this.addLine(`${ctxVar}[isBoundary] = 1;`);\r\n            this.helpers.add(\"isBoundary\");\r\n            const subCtx = createContext(ctx, { ctxVar });\r\n            const bl = this.compileMulti({ type: 3 /* Multi */, content: ast.body }, subCtx);\r\n            if (bl) {\r\n                this.helpers.add(\"zero\");\r\n                this.addLine(`${ctxVar}[zero] = ${bl};`);\r\n            }\r\n        }\r\n        const key = this.generateComponentKey();\r\n        if (isDynamic) {\r\n            const templateVar = generateId(\"template\");\r\n            if (!this.staticDefs.find((d) => d.id === \"call\")) {\r\n                this.staticDefs.push({ id: \"call\", expr: `app.callTemplate.bind(app)` });\r\n            }\r\n            this.define(templateVar, subTemplate);\r\n            this.insertBlock(`call(this, ${templateVar}, ${ctxVar}, node, ${key})`, block, {\r\n                ...ctx,\r\n                forceNewBlock: !block,\r\n            });\r\n        }\r\n        else {\r\n            const id = generateId(`callTemplate_`);\r\n            this.staticDefs.push({ id, expr: `app.getTemplate(${subTemplate})` });\r\n            this.insertBlock(`${id}.call(this, ${ctxVar}, node, ${key})`, block, {\r\n                ...ctx,\r\n                forceNewBlock: !block,\r\n            });\r\n        }\r\n        if (ast.body && !ctx.isLast) {\r\n            this.addLine(`${ctxVar} = ${ctxVar}.__proto__;`);\r\n        }\r\n        return block.varName;\r\n    }\r\n    compileTCallBlock(ast, ctx) {\r\n        let { block, forceNewBlock } = ctx;\r\n        if (block) {\r\n            if (!forceNewBlock) {\r\n                this.insertAnchor(block);\r\n            }\r\n        }\r\n        block = this.createBlock(block, \"multi\", ctx);\r\n        this.insertBlock(compileExpr(ast.name), block, { ...ctx, forceNewBlock: !block });\r\n        return block.varName;\r\n    }\r\n    compileTSet(ast, ctx) {\r\n        this.target.shouldProtectScope = true;\r\n        this.helpers.add(\"isBoundary\").add(\"withDefault\");\r\n        const expr = ast.value ? compileExpr(ast.value || \"\") : \"null\";\r\n        if (ast.body) {\r\n            this.helpers.add(\"LazyValue\");\r\n            const bodyAst = { type: 3 /* Multi */, content: ast.body };\r\n            const name = this.compileInNewTarget(\"value\", bodyAst, ctx);\r\n            let key = this.target.currentKey(ctx);\r\n            let value = `new LazyValue(${name}, ctx, this, node, ${key})`;\r\n            value = ast.value ? (value ? `withDefault(${expr}, ${value})` : expr) : value;\r\n            this.addLine(`ctx[\\`${ast.name}\\`] = ${value};`);\r\n        }\r\n        else {\r\n            let value;\r\n            if (ast.defaultValue) {\r\n                const defaultValue = toStringExpression(ctx.translate ? this.translate(ast.defaultValue, ctx.translationCtx) : ast.defaultValue);\r\n                if (ast.value) {\r\n                    value = `withDefault(${expr}, ${defaultValue})`;\r\n                }\r\n                else {\r\n                    value = defaultValue;\r\n                }\r\n            }\r\n            else {\r\n                value = expr;\r\n            }\r\n            this.helpers.add(\"setContextValue\");\r\n            this.addLine(`setContextValue(${ctx.ctxVar || \"ctx\"}, \"${ast.name}\", ${value});`);\r\n        }\r\n        return null;\r\n    }\r\n    generateComponentKey(currentKey = \"key\") {\r\n        const parts = [generateId(\"__\")];\r\n        for (let i = 0; i < this.target.loopLevel; i++) {\r\n            parts.push(`\\${key${i + 1}}`);\r\n        }\r\n        return `${currentKey} + \\`${parts.join(\"__\")}\\``;\r\n    }\r\n    /**\r\n     * Formats a prop name and value into a string suitable to be inserted in the\r\n     * generated code. For example:\r\n     *\r\n     * Name              Value            Result\r\n     * ---------------------------------------------------------\r\n     * \"number\"          \"state\"          \"number: ctx['state']\"\r\n     * \"something\"       \"\"               \"something: undefined\"\r\n     * \"some-prop\"       \"state\"          \"'some-prop': ctx['state']\"\r\n     * \"onClick.bind\"    \"onClick\"        \"onClick: bind(ctx, ctx['onClick'])\"\r\n     */\r\n    formatProp(name, value, attrsTranslationCtx, translationCtx) {\r\n        if (name.endsWith(\".translate\")) {\r\n            const attrTranslationCtx = (attrsTranslationCtx === null || attrsTranslationCtx === void 0 ? void 0 : attrsTranslationCtx[name]) || translationCtx;\r\n            value = toStringExpression(this.translateFn(value, attrTranslationCtx));\r\n        }\r\n        else {\r\n            value = this.captureExpression(value);\r\n        }\r\n        if (name.includes(\".\")) {\r\n            let [_name, suffix] = name.split(\".\");\r\n            name = _name;\r\n            switch (suffix) {\r\n                case \"bind\":\r\n                    value = `(${value}).bind(this)`;\r\n                    break;\r\n                case \"alike\":\r\n                case \"translate\":\r\n                    break;\r\n                default:\r\n                    throw new OwlError(`Invalid prop suffix: ${suffix}`);\r\n            }\r\n        }\r\n        name = /^[a-z_]+$/i.test(name) ? name : `'${name}'`;\r\n        return `${name}: ${value || undefined}`;\r\n    }\r\n    formatPropObject(obj, attrsTranslationCtx, translationCtx) {\r\n        return Object.entries(obj).map(([k, v]) => this.formatProp(k, v, attrsTranslationCtx, translationCtx));\r\n    }\r\n    getPropString(props, dynProps) {\r\n        let propString = `{${props.join(\",\")}}`;\r\n        if (dynProps) {\r\n            propString = `Object.assign({}, ${compileExpr(dynProps)}${props.length ? \", \" + propString : \"\"})`;\r\n        }\r\n        return propString;\r\n    }\r\n    compileComponent(ast, ctx) {\r\n        let { block } = ctx;\r\n        // props\r\n        const hasSlotsProp = \"slots\" in (ast.props || {});\r\n        const props = ast.props\r\n            ? this.formatPropObject(ast.props, ast.propsTranslationCtx, ctx.translationCtx)\r\n            : [];\r\n        // slots\r\n        let slotDef = \"\";\r\n        if (ast.slots) {\r\n            let ctxStr = \"ctx\";\r\n            if (this.target.loopLevel || !this.hasSafeContext) {\r\n                ctxStr = generateId(\"ctx\");\r\n                this.helpers.add(\"capture\");\r\n                this.define(ctxStr, `capture(ctx)`);\r\n            }\r\n            let slotStr = [];\r\n            for (let slotName in ast.slots) {\r\n                const slotAst = ast.slots[slotName];\r\n                const params = [];\r\n                if (slotAst.content) {\r\n                    const name = this.compileInNewTarget(\"slot\", slotAst.content, ctx, slotAst.on);\r\n                    params.push(`__render: ${name}.bind(this), __ctx: ${ctxStr}`);\r\n                }\r\n                const scope = ast.slots[slotName].scope;\r\n                if (scope) {\r\n                    params.push(`__scope: \"${scope}\"`);\r\n                }\r\n                if (ast.slots[slotName].attrs) {\r\n                    params.push(...this.formatPropObject(ast.slots[slotName].attrs, ast.slots[slotName].attrsTranslationCtx, ctx.translationCtx));\r\n                }\r\n                const slotInfo = `{${params.join(\", \")}}`;\r\n                slotStr.push(`'${slotName}': ${slotInfo}`);\r\n            }\r\n            slotDef = `{${slotStr.join(\", \")}}`;\r\n        }\r\n        if (slotDef && !(ast.dynamicProps || hasSlotsProp)) {\r\n            this.helpers.add(\"markRaw\");\r\n            props.push(`slots: markRaw(${slotDef})`);\r\n        }\r\n        let propString = this.getPropString(props, ast.dynamicProps);\r\n        let propVar;\r\n        if ((slotDef && (ast.dynamicProps || hasSlotsProp)) || this.dev) {\r\n            propVar = generateId(\"props\");\r\n            this.define(propVar, propString);\r\n            propString = propVar;\r\n        }\r\n        if (slotDef && (ast.dynamicProps || hasSlotsProp)) {\r\n            this.helpers.add(\"markRaw\");\r\n            this.addLine(`${propVar}.slots = markRaw(Object.assign(${slotDef}, ${propVar}.slots))`);\r\n        }\r\n        // cmap key\r\n        let expr;\r\n        if (ast.isDynamic) {\r\n            expr = generateId(\"Comp\");\r\n            this.define(expr, compileExpr(ast.name));\r\n        }\r\n        else {\r\n            expr = `\\`${ast.name}\\``;\r\n        }\r\n        if (this.dev) {\r\n            this.addLine(`helpers.validateProps(${expr}, ${propVar}, this);`);\r\n        }\r\n        if (block && (ctx.forceNewBlock === false || ctx.tKeyExpr)) {\r\n            // todo: check the forcenewblock condition\r\n            this.insertAnchor(block);\r\n        }\r\n        let keyArg = this.generateComponentKey();\r\n        if (ctx.tKeyExpr) {\r\n            keyArg = `${ctx.tKeyExpr} + ${keyArg}`;\r\n        }\r\n        let id = generateId(\"comp\");\r\n        const propList = [];\r\n        for (let p in ast.props || {}) {\r\n            let [name, suffix] = p.split(\".\");\r\n            if (!suffix) {\r\n                propList.push(`\"${name}\"`);\r\n            }\r\n        }\r\n        this.staticDefs.push({\r\n            id,\r\n            expr: `app.createComponent(${ast.isDynamic ? null : expr}, ${!ast.isDynamic}, ${!!ast.slots}, ${!!ast.dynamicProps}, [${propList}])`,\r\n        });\r\n        if (ast.isDynamic) {\r\n            // If the component class changes, this can cause delayed renders to go\r\n            // through if the key doesn't change. Use the component name for now.\r\n            // This means that two component classes with the same name isn't supported\r\n            // in t-component. We can generate a unique id per class later if needed.\r\n            keyArg = `(${expr}).name + ${keyArg}`;\r\n        }\r\n        let blockExpr = `${id}(${propString}, ${keyArg}, node, this, ${ast.isDynamic ? expr : null})`;\r\n        if (ast.isDynamic) {\r\n            blockExpr = `toggler(${expr}, ${blockExpr})`;\r\n        }\r\n        // event handling\r\n        if (ast.on) {\r\n            blockExpr = this.wrapWithEventCatcher(blockExpr, ast.on);\r\n        }\r\n        block = this.createBlock(block, \"multi\", ctx);\r\n        this.insertBlock(blockExpr, block, ctx);\r\n        return block.varName;\r\n    }\r\n    wrapWithEventCatcher(expr, on) {\r\n        this.helpers.add(\"createCatcher\");\r\n        let name = generateId(\"catcher\");\r\n        let spec = {};\r\n        let handlers = [];\r\n        for (let ev in on) {\r\n            let handlerId = generateId(\"hdlr\");\r\n            let idx = handlers.push(handlerId) - 1;\r\n            spec[ev] = idx;\r\n            const handler = this.generateHandlerCode(ev, on[ev]);\r\n            this.define(handlerId, handler);\r\n        }\r\n        this.staticDefs.push({ id: name, expr: `createCatcher(${JSON.stringify(spec)})` });\r\n        return `${name}(${expr}, [${handlers.join(\",\")}])`;\r\n    }\r\n    compileTSlot(ast, ctx) {\r\n        this.helpers.add(\"callSlot\");\r\n        let { block } = ctx;\r\n        let blockString;\r\n        let slotName;\r\n        let dynamic = false;\r\n        let isMultiple = false;\r\n        if (ast.name.match(INTERP_REGEXP)) {\r\n            dynamic = true;\r\n            isMultiple = true;\r\n            slotName = interpolate(ast.name);\r\n        }\r\n        else {\r\n            slotName = \"'\" + ast.name + \"'\";\r\n            isMultiple = isMultiple || this.slotNames.has(ast.name);\r\n            this.slotNames.add(ast.name);\r\n        }\r\n        const attrs = { ...ast.attrs };\r\n        const dynProps = attrs[\"t-props\"];\r\n        delete attrs[\"t-props\"];\r\n        let key = this.target.loopLevel ? `key${this.target.loopLevel}` : \"key\";\r\n        if (isMultiple) {\r\n            key = this.generateComponentKey(key);\r\n        }\r\n        const props = ast.attrs\r\n            ? this.formatPropObject(attrs, ast.attrsTranslationCtx, ctx.translationCtx)\r\n            : [];\r\n        const scope = this.getPropString(props, dynProps);\r\n        if (ast.defaultContent) {\r\n            const name = this.compileInNewTarget(\"defaultContent\", ast.defaultContent, ctx);\r\n            blockString = `callSlot(ctx, node, ${key}, ${slotName}, ${dynamic}, ${scope}, ${name}.bind(this))`;\r\n        }\r\n        else {\r\n            if (dynamic) {\r\n                let name = generateId(\"slot\");\r\n                this.define(name, slotName);\r\n                blockString = `toggler(${name}, callSlot(ctx, node, ${key}, ${name}, ${dynamic}, ${scope}))`;\r\n            }\r\n            else {\r\n                blockString = `callSlot(ctx, node, ${key}, ${slotName}, ${dynamic}, ${scope})`;\r\n            }\r\n        }\r\n        // event handling\r\n        if (ast.on) {\r\n            blockString = this.wrapWithEventCatcher(blockString, ast.on);\r\n        }\r\n        if (block) {\r\n            this.insertAnchor(block);\r\n        }\r\n        block = this.createBlock(block, \"multi\", ctx);\r\n        this.insertBlock(blockString, block, { ...ctx, forceNewBlock: false });\r\n        return block.varName;\r\n    }\r\n    compileTTranslation(ast, ctx) {\r\n        if (ast.content) {\r\n            return this.compileAST(ast.content, Object.assign({}, ctx, { translate: false }));\r\n        }\r\n        return null;\r\n    }\r\n    compileTTranslationContext(ast, ctx) {\r\n        if (ast.content) {\r\n            return this.compileAST(ast.content, Object.assign({}, ctx, { translationCtx: ast.translationCtx }));\r\n        }\r\n        return null;\r\n    }\r\n    compileTPortal(ast, ctx) {\r\n        if (!this.staticDefs.find((d) => d.id === \"Portal\")) {\r\n            this.staticDefs.push({ id: \"Portal\", expr: `app.Portal` });\r\n        }\r\n        let { block } = ctx;\r\n        const name = this.compileInNewTarget(\"slot\", ast.content, ctx);\r\n        let ctxStr = \"ctx\";\r\n        if (this.target.loopLevel || !this.hasSafeContext) {\r\n            ctxStr = generateId(\"ctx\");\r\n            this.helpers.add(\"capture\");\r\n            this.define(ctxStr, `capture(ctx)`);\r\n        }\r\n        let id = generateId(\"comp\");\r\n        this.staticDefs.push({\r\n            id,\r\n            expr: `app.createComponent(null, false, true, false, false)`,\r\n        });\r\n        const target = compileExpr(ast.target);\r\n        const key = this.generateComponentKey();\r\n        const blockString = `${id}({target: ${target},slots: {'default': {__render: ${name}.bind(this), __ctx: ${ctxStr}}}}, ${key}, node, ctx, Portal)`;\r\n        if (block) {\r\n            this.insertAnchor(block);\r\n        }\r\n        block = this.createBlock(block, \"multi\", ctx);\r\n        this.insertBlock(blockString, block, { ...ctx, forceNewBlock: false });\r\n        return block.varName;\r\n    }\r\n}\n\n// -----------------------------------------------------------------------------\r\n// Parser\r\n// -----------------------------------------------------------------------------\r\nconst cache = new WeakMap();\r\nfunction parse(xml, customDir) {\r\n    const ctx = {\r\n        inPreTag: false,\r\n        customDirectives: customDir,\r\n    };\r\n    if (typeof xml === \"string\") {\r\n        const elem = parseXML(`<t>${xml}</t>`).firstChild;\r\n        return _parse(elem, ctx);\r\n    }\r\n    let ast = cache.get(xml);\r\n    if (!ast) {\r\n        // we clone here the xml to prevent modifying it in place\r\n        ast = _parse(xml.cloneNode(true), ctx);\r\n        cache.set(xml, ast);\r\n    }\r\n    return ast;\r\n}\r\nfunction _parse(xml, ctx) {\r\n    normalizeXML(xml);\r\n    return parseNode(xml, ctx) || { type: 0 /* Text */, value: \"\" };\r\n}\r\nfunction parseNode(node, ctx) {\r\n    if (!(node instanceof Element)) {\r\n        return parseTextCommentNode(node, ctx);\r\n    }\r\n    return (parseTCustom(node, ctx) ||\r\n        parseTDebugLog(node, ctx) ||\r\n        parseTForEach(node, ctx) ||\r\n        parseTIf(node, ctx) ||\r\n        parseTPortal(node, ctx) ||\r\n        parseTCall(node, ctx) ||\r\n        parseTCallBlock(node) ||\r\n        parseTTranslation(node, ctx) ||\r\n        parseTTranslationContext(node, ctx) ||\r\n        parseTKey(node, ctx) ||\r\n        parseTEscNode(node, ctx) ||\r\n        parseTOutNode(node, ctx) ||\r\n        parseTSlot(node, ctx) ||\r\n        parseComponent(node, ctx) ||\r\n        parseDOMNode(node, ctx) ||\r\n        parseTSetNode(node, ctx) ||\r\n        parseTNode(node, ctx));\r\n}\r\n// -----------------------------------------------------------------------------\r\n// <t /> tag\r\n// -----------------------------------------------------------------------------\r\nfunction parseTNode(node, ctx) {\r\n    if (node.tagName !== \"t\") {\r\n        return null;\r\n    }\r\n    return parseChildNodes(node, ctx);\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Text and Comment Nodes\r\n// -----------------------------------------------------------------------------\r\nconst lineBreakRE = /[\\r\\n]/;\r\nfunction parseTextCommentNode(node, ctx) {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n        let value = node.textContent || \"\";\r\n        if (!ctx.inPreTag && lineBreakRE.test(value) && !value.trim()) {\r\n            return null;\r\n        }\r\n        return { type: 0 /* Text */, value };\r\n    }\r\n    else if (node.nodeType === Node.COMMENT_NODE) {\r\n        return { type: 1 /* Comment */, value: node.textContent || \"\" };\r\n    }\r\n    return null;\r\n}\r\nfunction parseTCustom(node, ctx) {\r\n    if (!ctx.customDirectives) {\r\n        return null;\r\n    }\r\n    const nodeAttrsNames = node.getAttributeNames();\r\n    for (let attr of nodeAttrsNames) {\r\n        if (attr === \"t-custom\" || attr === \"t-custom-\") {\r\n            throw new OwlError(\"Missing custom directive name with t-custom directive\");\r\n        }\r\n        if (attr.startsWith(\"t-custom-\")) {\r\n            const directiveName = attr.split(\".\")[0].slice(9);\r\n            const customDirective = ctx.customDirectives[directiveName];\r\n            if (!customDirective) {\r\n                throw new OwlError(`Custom directive \"${directiveName}\" is not defined`);\r\n            }\r\n            const value = node.getAttribute(attr);\r\n            const modifiers = attr.split(\".\").slice(1);\r\n            node.removeAttribute(attr);\r\n            try {\r\n                customDirective(node, value, modifiers);\r\n            }\r\n            catch (error) {\r\n                throw new OwlError(`Custom directive \"${directiveName}\" throw the following error: ${error}`);\r\n            }\r\n            return parseNode(node, ctx);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// debugging\r\n// -----------------------------------------------------------------------------\r\nfunction parseTDebugLog(node, ctx) {\r\n    if (node.hasAttribute(\"t-debug\")) {\r\n        node.removeAttribute(\"t-debug\");\r\n        const content = parseNode(node, ctx);\r\n        const ast = {\r\n            type: 12 /* TDebug */,\r\n            content,\r\n        };\r\n        if (content === null || content === void 0 ? void 0 : content.hasNoRepresentation) {\r\n            ast.hasNoRepresentation = true;\r\n        }\r\n        return ast;\r\n    }\r\n    if (node.hasAttribute(\"t-log\")) {\r\n        const expr = node.getAttribute(\"t-log\");\r\n        node.removeAttribute(\"t-log\");\r\n        const content = parseNode(node, ctx);\r\n        const ast = {\r\n            type: 13 /* TLog */,\r\n            expr,\r\n            content,\r\n        };\r\n        if (content === null || content === void 0 ? void 0 : content.hasNoRepresentation) {\r\n            ast.hasNoRepresentation = true;\r\n        }\r\n        return ast;\r\n    }\r\n    return null;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Regular dom node\r\n// -----------------------------------------------------------------------------\r\nconst hasDotAtTheEnd = /\\.[\\w_]+\\s*$/;\r\nconst hasBracketsAtTheEnd = /\\[[^\\[]+\\]\\s*$/;\r\nconst ROOT_SVG_TAGS = new Set([\"svg\", \"g\", \"path\"]);\r\nfunction parseDOMNode(node, ctx) {\r\n    const { tagName } = node;\r\n    const dynamicTag = node.getAttribute(\"t-tag\");\r\n    node.removeAttribute(\"t-tag\");\r\n    if (tagName === \"t\" && !dynamicTag) {\r\n        return null;\r\n    }\r\n    if (tagName.startsWith(\"block-\")) {\r\n        throw new OwlError(`Invalid tag name: '${tagName}'`);\r\n    }\r\n    ctx = Object.assign({}, ctx);\r\n    if (tagName === \"pre\") {\r\n        ctx.inPreTag = true;\r\n    }\r\n    let ns = !ctx.nameSpace && ROOT_SVG_TAGS.has(tagName) ? \"http://www.w3.org/2000/svg\" : null;\r\n    const ref = node.getAttribute(\"t-ref\");\r\n    node.removeAttribute(\"t-ref\");\r\n    const nodeAttrsNames = node.getAttributeNames();\r\n    let attrs = null;\r\n    let attrsTranslationCtx = null;\r\n    let on = null;\r\n    let model = null;\r\n    for (let attr of nodeAttrsNames) {\r\n        const value = node.getAttribute(attr);\r\n        if (attr === \"t-on\" || attr === \"t-on-\") {\r\n            throw new OwlError(\"Missing event name with t-on directive\");\r\n        }\r\n        if (attr.startsWith(\"t-on-\")) {\r\n            on = on || {};\r\n            on[attr.slice(5)] = value;\r\n        }\r\n        else if (attr.startsWith(\"t-model\")) {\r\n            if (![\"input\", \"select\", \"textarea\"].includes(tagName)) {\r\n                throw new OwlError(\"The t-model directive only works with <input>, <textarea> and <select>\");\r\n            }\r\n            let baseExpr, expr;\r\n            if (hasDotAtTheEnd.test(value)) {\r\n                const index = value.lastIndexOf(\".\");\r\n                baseExpr = value.slice(0, index);\r\n                expr = `'${value.slice(index + 1)}'`;\r\n            }\r\n            else if (hasBracketsAtTheEnd.test(value)) {\r\n                const index = value.lastIndexOf(\"[\");\r\n                baseExpr = value.slice(0, index);\r\n                expr = value.slice(index + 1, -1);\r\n            }\r\n            else {\r\n                throw new OwlError(`Invalid t-model expression: \"${value}\" (it should be assignable)`);\r\n            }\r\n            const typeAttr = node.getAttribute(\"type\");\r\n            const isInput = tagName === \"input\";\r\n            const isSelect = tagName === \"select\";\r\n            const isCheckboxInput = isInput && typeAttr === \"checkbox\";\r\n            const isRadioInput = isInput && typeAttr === \"radio\";\r\n            const hasTrimMod = attr.includes(\".trim\");\r\n            const hasLazyMod = hasTrimMod || attr.includes(\".lazy\");\r\n            const hasNumberMod = attr.includes(\".number\");\r\n            const eventType = isRadioInput ? \"click\" : isSelect || hasLazyMod ? \"change\" : \"input\";\r\n            model = {\r\n                baseExpr,\r\n                expr,\r\n                targetAttr: isCheckboxInput ? \"checked\" : \"value\",\r\n                specialInitTargetAttr: isRadioInput ? \"checked\" : null,\r\n                eventType,\r\n                hasDynamicChildren: false,\r\n                shouldTrim: hasTrimMod,\r\n                shouldNumberize: hasNumberMod,\r\n            };\r\n            if (isSelect) {\r\n                // don't pollute the original ctx\r\n                ctx = Object.assign({}, ctx);\r\n                ctx.tModelInfo = model;\r\n            }\r\n        }\r\n        else if (attr.startsWith(\"block-\")) {\r\n            throw new OwlError(`Invalid attribute: '${attr}'`);\r\n        }\r\n        else if (attr === \"xmlns\") {\r\n            ns = value;\r\n        }\r\n        else if (attr.startsWith(\"t-translation-context-\")) {\r\n            const attrName = attr.slice(22);\r\n            attrsTranslationCtx = attrsTranslationCtx || {};\r\n            attrsTranslationCtx[attrName] = value;\r\n        }\r\n        else if (attr !== \"t-name\") {\r\n            if (attr.startsWith(\"t-\") && !attr.startsWith(\"t-att\")) {\r\n                throw new OwlError(`Unknown QWeb directive: '${attr}'`);\r\n            }\r\n            const tModel = ctx.tModelInfo;\r\n            if (tModel && [\"t-att-value\", \"t-attf-value\"].includes(attr)) {\r\n                tModel.hasDynamicChildren = true;\r\n            }\r\n            attrs = attrs || {};\r\n            attrs[attr] = value;\r\n        }\r\n    }\r\n    if (ns) {\r\n        ctx.nameSpace = ns;\r\n    }\r\n    const children = parseChildren(node, ctx);\r\n    return {\r\n        type: 2 /* DomNode */,\r\n        tag: tagName,\r\n        dynamicTag,\r\n        attrs,\r\n        attrsTranslationCtx,\r\n        on,\r\n        ref,\r\n        content: children,\r\n        model,\r\n        ns,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-esc\r\n// -----------------------------------------------------------------------------\r\nfunction parseTEscNode(node, ctx) {\r\n    if (!node.hasAttribute(\"t-esc\")) {\r\n        return null;\r\n    }\r\n    const escValue = node.getAttribute(\"t-esc\");\r\n    node.removeAttribute(\"t-esc\");\r\n    const tesc = {\r\n        type: 4 /* TEsc */,\r\n        expr: escValue,\r\n        defaultValue: node.textContent || \"\",\r\n    };\r\n    let ref = node.getAttribute(\"t-ref\");\r\n    node.removeAttribute(\"t-ref\");\r\n    const ast = parseNode(node, ctx);\r\n    if (!ast) {\r\n        return tesc;\r\n    }\r\n    if (ast.type === 2 /* DomNode */) {\r\n        return {\r\n            ...ast,\r\n            ref,\r\n            content: [tesc],\r\n        };\r\n    }\r\n    return tesc;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-out\r\n// -----------------------------------------------------------------------------\r\nfunction parseTOutNode(node, ctx) {\r\n    if (!node.hasAttribute(\"t-out\") && !node.hasAttribute(\"t-raw\")) {\r\n        return null;\r\n    }\r\n    if (node.hasAttribute(\"t-raw\")) {\r\n        console.warn(`t-raw has been deprecated in favor of t-out. If the value to render is not wrapped by the \"markup\" function, it will be escaped`);\r\n    }\r\n    const expr = (node.getAttribute(\"t-out\") || node.getAttribute(\"t-raw\"));\r\n    node.removeAttribute(\"t-out\");\r\n    node.removeAttribute(\"t-raw\");\r\n    const tOut = { type: 8 /* TOut */, expr, body: null };\r\n    const ref = node.getAttribute(\"t-ref\");\r\n    node.removeAttribute(\"t-ref\");\r\n    const ast = parseNode(node, ctx);\r\n    if (!ast) {\r\n        return tOut;\r\n    }\r\n    if (ast.type === 2 /* DomNode */) {\r\n        tOut.body = ast.content.length ? ast.content : null;\r\n        return {\r\n            ...ast,\r\n            ref,\r\n            content: [tOut],\r\n        };\r\n    }\r\n    return tOut;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-foreach and t-key\r\n// -----------------------------------------------------------------------------\r\nfunction parseTForEach(node, ctx) {\r\n    if (!node.hasAttribute(\"t-foreach\")) {\r\n        return null;\r\n    }\r\n    const html = node.outerHTML;\r\n    const collection = node.getAttribute(\"t-foreach\");\r\n    node.removeAttribute(\"t-foreach\");\r\n    const elem = node.getAttribute(\"t-as\") || \"\";\r\n    node.removeAttribute(\"t-as\");\r\n    const key = node.getAttribute(\"t-key\");\r\n    if (!key) {\r\n        throw new OwlError(`\"Directive t-foreach should always be used with a t-key!\" (expression: t-foreach=\"${collection}\" t-as=\"${elem}\")`);\r\n    }\r\n    node.removeAttribute(\"t-key\");\r\n    const memo = node.getAttribute(\"t-memo\") || \"\";\r\n    node.removeAttribute(\"t-memo\");\r\n    const body = parseNode(node, ctx);\r\n    if (!body) {\r\n        return null;\r\n    }\r\n    const hasNoTCall = !html.includes(\"t-call\");\r\n    const hasNoFirst = hasNoTCall && !html.includes(`${elem}_first`);\r\n    const hasNoLast = hasNoTCall && !html.includes(`${elem}_last`);\r\n    const hasNoIndex = hasNoTCall && !html.includes(`${elem}_index`);\r\n    const hasNoValue = hasNoTCall && !html.includes(`${elem}_value`);\r\n    return {\r\n        type: 9 /* TForEach */,\r\n        collection,\r\n        elem,\r\n        body,\r\n        memo,\r\n        key,\r\n        hasNoFirst,\r\n        hasNoLast,\r\n        hasNoIndex,\r\n        hasNoValue,\r\n    };\r\n}\r\nfunction parseTKey(node, ctx) {\r\n    if (!node.hasAttribute(\"t-key\")) {\r\n        return null;\r\n    }\r\n    const key = node.getAttribute(\"t-key\");\r\n    node.removeAttribute(\"t-key\");\r\n    const content = parseNode(node, ctx);\r\n    if (!content) {\r\n        return null;\r\n    }\r\n    const ast = {\r\n        type: 10 /* TKey */,\r\n        expr: key,\r\n        content,\r\n    };\r\n    if (content.hasNoRepresentation) {\r\n        ast.hasNoRepresentation = true;\r\n    }\r\n    return ast;\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-call\r\n// -----------------------------------------------------------------------------\r\nfunction parseTCall(node, ctx) {\r\n    if (!node.hasAttribute(\"t-call\")) {\r\n        return null;\r\n    }\r\n    const subTemplate = node.getAttribute(\"t-call\");\r\n    const context = node.getAttribute(\"t-call-context\");\r\n    node.removeAttribute(\"t-call\");\r\n    node.removeAttribute(\"t-call-context\");\r\n    if (node.tagName !== \"t\") {\r\n        const ast = parseNode(node, ctx);\r\n        const tcall = { type: 7 /* TCall */, name: subTemplate, body: null, context };\r\n        if (ast && ast.type === 2 /* DomNode */) {\r\n            ast.content = [tcall];\r\n            return ast;\r\n        }\r\n        if (ast && ast.type === 11 /* TComponent */) {\r\n            return {\r\n                ...ast,\r\n                slots: {\r\n                    default: {\r\n                        content: tcall,\r\n                        scope: null,\r\n                        on: null,\r\n                        attrs: null,\r\n                        attrsTranslationCtx: null,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n    }\r\n    const body = parseChildren(node, ctx);\r\n    return {\r\n        type: 7 /* TCall */,\r\n        name: subTemplate,\r\n        body: body.length ? body : null,\r\n        context,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-call-block\r\n// -----------------------------------------------------------------------------\r\nfunction parseTCallBlock(node, ctx) {\r\n    if (!node.hasAttribute(\"t-call-block\")) {\r\n        return null;\r\n    }\r\n    const name = node.getAttribute(\"t-call-block\");\r\n    return {\r\n        type: 15 /* TCallBlock */,\r\n        name,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-if\r\n// -----------------------------------------------------------------------------\r\nfunction parseTIf(node, ctx) {\r\n    if (!node.hasAttribute(\"t-if\")) {\r\n        return null;\r\n    }\r\n    const condition = node.getAttribute(\"t-if\");\r\n    node.removeAttribute(\"t-if\");\r\n    const content = parseNode(node, ctx) || { type: 0 /* Text */, value: \"\" };\r\n    let nextElement = node.nextElementSibling;\r\n    // t-elifs\r\n    const tElifs = [];\r\n    while (nextElement && nextElement.hasAttribute(\"t-elif\")) {\r\n        const condition = nextElement.getAttribute(\"t-elif\");\r\n        nextElement.removeAttribute(\"t-elif\");\r\n        const tElif = parseNode(nextElement, ctx);\r\n        const next = nextElement.nextElementSibling;\r\n        nextElement.remove();\r\n        nextElement = next;\r\n        if (tElif) {\r\n            tElifs.push({ condition, content: tElif });\r\n        }\r\n    }\r\n    // t-else\r\n    let tElse = null;\r\n    if (nextElement && nextElement.hasAttribute(\"t-else\")) {\r\n        nextElement.removeAttribute(\"t-else\");\r\n        tElse = parseNode(nextElement, ctx);\r\n        nextElement.remove();\r\n    }\r\n    return {\r\n        type: 5 /* TIf */,\r\n        condition,\r\n        content,\r\n        tElif: tElifs.length ? tElifs : null,\r\n        tElse,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// t-set directive\r\n// -----------------------------------------------------------------------------\r\nfunction parseTSetNode(node, ctx) {\r\n    if (!node.hasAttribute(\"t-set\")) {\r\n        return null;\r\n    }\r\n    const name = node.getAttribute(\"t-set\");\r\n    const value = node.getAttribute(\"t-value\") || null;\r\n    const defaultValue = node.innerHTML === node.textContent ? node.textContent || null : null;\r\n    let body = null;\r\n    if (node.textContent !== node.innerHTML) {\r\n        body = parseChildren(node, ctx);\r\n    }\r\n    return { type: 6 /* TSet */, name, value, defaultValue, body, hasNoRepresentation: true };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Components\r\n// -----------------------------------------------------------------------------\r\n// Error messages when trying to use an unsupported directive on a component\r\nconst directiveErrorMap = new Map([\r\n    [\r\n        \"t-ref\",\r\n        \"t-ref is no longer supported on components. Consider exposing only the public part of the component's API through a callback prop.\",\r\n    ],\r\n    [\"t-att\", \"t-att makes no sense on component: props are already treated as expressions\"],\r\n    [\r\n        \"t-attf\",\r\n        \"t-attf is not supported on components: use template strings for string interpolation in props\",\r\n    ],\r\n]);\r\nfunction parseComponent(node, ctx) {\r\n    let name = node.tagName;\r\n    const firstLetter = name[0];\r\n    let isDynamic = node.hasAttribute(\"t-component\");\r\n    if (isDynamic && name !== \"t\") {\r\n        throw new OwlError(`Directive 't-component' can only be used on <t> nodes (used on a <${name}>)`);\r\n    }\r\n    if (!(firstLetter === firstLetter.toUpperCase() || isDynamic)) {\r\n        return null;\r\n    }\r\n    if (isDynamic) {\r\n        name = node.getAttribute(\"t-component\");\r\n        node.removeAttribute(\"t-component\");\r\n    }\r\n    const dynamicProps = node.getAttribute(\"t-props\");\r\n    node.removeAttribute(\"t-props\");\r\n    const defaultSlotScope = node.getAttribute(\"t-slot-scope\");\r\n    node.removeAttribute(\"t-slot-scope\");\r\n    let on = null;\r\n    let props = null;\r\n    let propsTranslationCtx = null;\r\n    for (let name of node.getAttributeNames()) {\r\n        const value = node.getAttribute(name);\r\n        if (name.startsWith(\"t-translation-context-\")) {\r\n            const attrName = name.slice(22);\r\n            propsTranslationCtx = propsTranslationCtx || {};\r\n            propsTranslationCtx[attrName] = value;\r\n        }\r\n        else if (name.startsWith(\"t-\")) {\r\n            if (name.startsWith(\"t-on-\")) {\r\n                on = on || {};\r\n                on[name.slice(5)] = value;\r\n            }\r\n            else {\r\n                const message = directiveErrorMap.get(name.split(\"-\").slice(0, 2).join(\"-\"));\r\n                throw new OwlError(message || `unsupported directive on Component: ${name}`);\r\n            }\r\n        }\r\n        else {\r\n            props = props || {};\r\n            props[name] = value;\r\n        }\r\n    }\r\n    let slots = null;\r\n    if (node.hasChildNodes()) {\r\n        const clone = node.cloneNode(true);\r\n        // named slots\r\n        const slotNodes = Array.from(clone.querySelectorAll(\"[t-set-slot]\"));\r\n        for (let slotNode of slotNodes) {\r\n            if (slotNode.tagName !== \"t\") {\r\n                throw new OwlError(`Directive 't-set-slot' can only be used on <t> nodes (used on a <${slotNode.tagName}>)`);\r\n            }\r\n            const name = slotNode.getAttribute(\"t-set-slot\");\r\n            // check if this is defined in a sub component (in which case it should\r\n            // be ignored)\r\n            let el = slotNode.parentElement;\r\n            let isInSubComponent = false;\r\n            while (el && el !== clone) {\r\n                if (el.hasAttribute(\"t-component\") || el.tagName[0] === el.tagName[0].toUpperCase()) {\r\n                    isInSubComponent = true;\r\n                    break;\r\n                }\r\n                el = el.parentElement;\r\n            }\r\n            if (isInSubComponent || !el) {\r\n                continue;\r\n            }\r\n            slotNode.removeAttribute(\"t-set-slot\");\r\n            slotNode.remove();\r\n            const slotAst = parseNode(slotNode, ctx);\r\n            let on = null;\r\n            let attrs = null;\r\n            let attrsTranslationCtx = null;\r\n            let scope = null;\r\n            for (let attributeName of slotNode.getAttributeNames()) {\r\n                const value = slotNode.getAttribute(attributeName);\r\n                if (attributeName === \"t-slot-scope\") {\r\n                    scope = value;\r\n                    continue;\r\n                }\r\n                else if (attributeName.startsWith(\"t-translation-context-\")) {\r\n                    const attrName = attributeName.slice(22);\r\n                    attrsTranslationCtx = attrsTranslationCtx || {};\r\n                    attrsTranslationCtx[attrName] = value;\r\n                }\r\n                else if (attributeName.startsWith(\"t-on-\")) {\r\n                    on = on || {};\r\n                    on[attributeName.slice(5)] = value;\r\n                }\r\n                else {\r\n                    attrs = attrs || {};\r\n                    attrs[attributeName] = value;\r\n                }\r\n            }\r\n            slots = slots || {};\r\n            slots[name] = { content: slotAst, on, attrs, attrsTranslationCtx, scope };\r\n        }\r\n        // default slot\r\n        const defaultContent = parseChildNodes(clone, ctx);\r\n        slots = slots || {};\r\n        // t-set-slot=\"default\" has priority over content\r\n        if (defaultContent && !slots.default) {\r\n            slots.default = {\r\n                content: defaultContent,\r\n                on,\r\n                attrs: null,\r\n                attrsTranslationCtx: null,\r\n                scope: defaultSlotScope,\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        type: 11 /* TComponent */,\r\n        name,\r\n        isDynamic,\r\n        dynamicProps,\r\n        props,\r\n        propsTranslationCtx,\r\n        slots,\r\n        on,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Slots\r\n// -----------------------------------------------------------------------------\r\nfunction parseTSlot(node, ctx) {\r\n    if (!node.hasAttribute(\"t-slot\")) {\r\n        return null;\r\n    }\r\n    const name = node.getAttribute(\"t-slot\");\r\n    node.removeAttribute(\"t-slot\");\r\n    let attrs = null;\r\n    let attrsTranslationCtx = null;\r\n    let on = null;\r\n    for (let attributeName of node.getAttributeNames()) {\r\n        const value = node.getAttribute(attributeName);\r\n        if (attributeName.startsWith(\"t-on-\")) {\r\n            on = on || {};\r\n            on[attributeName.slice(5)] = value;\r\n        }\r\n        else if (attributeName.startsWith(\"t-translation-context-\")) {\r\n            const attrName = attributeName.slice(22);\r\n            attrsTranslationCtx = attrsTranslationCtx || {};\r\n            attrsTranslationCtx[attrName] = value;\r\n        }\r\n        else {\r\n            attrs = attrs || {};\r\n            attrs[attributeName] = value;\r\n        }\r\n    }\r\n    return {\r\n        type: 14 /* TSlot */,\r\n        name,\r\n        attrs,\r\n        attrsTranslationCtx,\r\n        on,\r\n        defaultContent: parseChildNodes(node, ctx),\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Translation\r\n// -----------------------------------------------------------------------------\r\nfunction wrapInTTranslationAST(r) {\r\n    const ast = { type: 16 /* TTranslation */, content: r };\r\n    if (r === null || r === void 0 ? void 0 : r.hasNoRepresentation) {\r\n        ast.hasNoRepresentation = true;\r\n    }\r\n    return ast;\r\n}\r\nfunction parseTTranslation(node, ctx) {\r\n    if (node.getAttribute(\"t-translation\") !== \"off\") {\r\n        return null;\r\n    }\r\n    node.removeAttribute(\"t-translation\");\r\n    const result = parseNode(node, ctx);\r\n    if ((result === null || result === void 0 ? void 0 : result.type) === 3 /* Multi */) {\r\n        const children = result.content.map(wrapInTTranslationAST);\r\n        return makeASTMulti(children);\r\n    }\r\n    return wrapInTTranslationAST(result);\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Translation Context\r\n// -----------------------------------------------------------------------------\r\nfunction wrapInTTranslationContextAST(r, translationCtx) {\r\n    const ast = {\r\n        type: 17 /* TTranslationContext */,\r\n        content: r,\r\n        translationCtx,\r\n    };\r\n    if (r === null || r === void 0 ? void 0 : r.hasNoRepresentation) {\r\n        ast.hasNoRepresentation = true;\r\n    }\r\n    return ast;\r\n}\r\nfunction parseTTranslationContext(node, ctx) {\r\n    const translationCtx = node.getAttribute(\"t-translation-context\");\r\n    if (!translationCtx) {\r\n        return null;\r\n    }\r\n    node.removeAttribute(\"t-translation-context\");\r\n    const result = parseNode(node, ctx);\r\n    if ((result === null || result === void 0 ? void 0 : result.type) === 3 /* Multi */) {\r\n        const children = result.content.map((c) => wrapInTTranslationContextAST(c, translationCtx));\r\n        return makeASTMulti(children);\r\n    }\r\n    return wrapInTTranslationContextAST(result, translationCtx);\r\n}\r\n// -----------------------------------------------------------------------------\r\n// Portal\r\n// -----------------------------------------------------------------------------\r\nfunction parseTPortal(node, ctx) {\r\n    if (!node.hasAttribute(\"t-portal\")) {\r\n        return null;\r\n    }\r\n    const target = node.getAttribute(\"t-portal\");\r\n    node.removeAttribute(\"t-portal\");\r\n    const content = parseNode(node, ctx);\r\n    if (!content) {\r\n        return {\r\n            type: 0 /* Text */,\r\n            value: \"\",\r\n        };\r\n    }\r\n    return {\r\n        type: 18 /* TPortal */,\r\n        target,\r\n        content,\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// helpers\r\n// -----------------------------------------------------------------------------\r\n/**\r\n * Parse all the child nodes of a given node and return a list of ast elements\r\n */\r\nfunction parseChildren(node, ctx) {\r\n    const children = [];\r\n    for (let child of node.childNodes) {\r\n        const childAst = parseNode(child, ctx);\r\n        if (childAst) {\r\n            if (childAst.type === 3 /* Multi */) {\r\n                children.push(...childAst.content);\r\n            }\r\n            else {\r\n                children.push(childAst);\r\n            }\r\n        }\r\n    }\r\n    return children;\r\n}\r\nfunction makeASTMulti(children) {\r\n    const ast = { type: 3 /* Multi */, content: children };\r\n    if (children.every((c) => c.hasNoRepresentation)) {\r\n        ast.hasNoRepresentation = true;\r\n    }\r\n    return ast;\r\n}\r\n/**\r\n * Parse all the child nodes of a given node and return an ast if possible.\r\n * In the case there are multiple children, they are wrapped in a astmulti.\r\n */\r\nfunction parseChildNodes(node, ctx) {\r\n    const children = parseChildren(node, ctx);\r\n    switch (children.length) {\r\n        case 0:\r\n            return null;\r\n        case 1:\r\n            return children[0];\r\n        default:\r\n            return makeASTMulti(children);\r\n    }\r\n}\r\n/**\r\n * Normalizes the content of an Element so that t-if/t-elif/t-else directives\r\n * immediately follow one another (by removing empty text nodes or comments).\r\n * Throws an error when a conditional branching statement is malformed. This\r\n * function modifies the Element in place.\r\n *\r\n * @param el the element containing the tree that should be normalized\r\n */\r\nfunction normalizeTIf(el) {\r\n    let tbranch = el.querySelectorAll(\"[t-elif], [t-else]\");\r\n    for (let i = 0, ilen = tbranch.length; i < ilen; i++) {\r\n        let node = tbranch[i];\r\n        let prevElem = node.previousElementSibling;\r\n        let pattr = (name) => prevElem.getAttribute(name);\r\n        let nattr = (name) => +!!node.getAttribute(name);\r\n        if (prevElem && (pattr(\"t-if\") || pattr(\"t-elif\"))) {\r\n            if (pattr(\"t-foreach\")) {\r\n                throw new OwlError(\"t-if cannot stay at the same level as t-foreach when using t-elif or t-else\");\r\n            }\r\n            if ([\"t-if\", \"t-elif\", \"t-else\"].map(nattr).reduce(function (a, b) {\r\n                return a + b;\r\n            }) > 1) {\r\n                throw new OwlError(\"Only one conditional branching directive is allowed per node\");\r\n            }\r\n            // All text (with only spaces) and comment nodes (nodeType 8) between\r\n            // branch nodes are removed\r\n            let textNode;\r\n            while ((textNode = node.previousSibling) !== prevElem) {\r\n                if (textNode.nodeValue.trim().length && textNode.nodeType !== 8) {\r\n                    throw new OwlError(\"text is not allowed between branching directives\");\r\n                }\r\n                textNode.remove();\r\n            }\r\n        }\r\n        else {\r\n            throw new OwlError(\"t-elif and t-else directives must be preceded by a t-if or t-elif directive\");\r\n        }\r\n    }\r\n}\r\n/**\r\n * Normalizes the content of an Element so that t-esc directives on components\r\n * are removed and instead places a <t t-esc=\"\"> as the default slot of the\r\n * component. Also throws if the component already has content. This function\r\n * modifies the Element in place.\r\n *\r\n * @param el the element containing the tree that should be normalized\r\n */\r\nfunction normalizeTEscTOut(el) {\r\n    for (const d of [\"t-esc\", \"t-out\"]) {\r\n        const elements = [...el.querySelectorAll(`[${d}]`)].filter((el) => el.tagName[0] === el.tagName[0].toUpperCase() || el.hasAttribute(\"t-component\"));\r\n        for (const el of elements) {\r\n            if (el.childNodes.length) {\r\n                throw new OwlError(`Cannot have ${d} on a component that already has content`);\r\n            }\r\n            const value = el.getAttribute(d);\r\n            el.removeAttribute(d);\r\n            const t = el.ownerDocument.createElement(\"t\");\r\n            if (value != null) {\r\n                t.setAttribute(d, value);\r\n            }\r\n            el.appendChild(t);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Normalizes the tree inside a given element and do some preliminary validation\r\n * on it. This function modifies the Element in place.\r\n *\r\n * @param el the element containing the tree that should be normalized\r\n */\r\nfunction normalizeXML(el) {\r\n    normalizeTIf(el);\r\n    normalizeTEscTOut(el);\r\n}\n\nfunction compile(template, options = {\r\n    hasGlobalValues: false,\r\n}) {\r\n    // parsing\r\n    const ast = parse(template, options.customDirectives);\r\n    // some work\r\n    const hasSafeContext = template instanceof Node\r\n        ? !(template instanceof Element) || template.querySelector(\"[t-set], [t-call]\") === null\r\n        : !template.includes(\"t-set\") && !template.includes(\"t-call\");\r\n    // code generation\r\n    const codeGenerator = new CodeGenerator(ast, { ...options, hasSafeContext });\r\n    const code = codeGenerator.generateCode();\r\n    // template function\r\n    try {\r\n        return new Function(\"app, bdom, helpers\", code);\r\n    }\r\n    catch (originalError) {\r\n        const { name } = options;\r\n        const nameStr = name ? `template \"${name}\"` : \"anonymous template\";\r\n        const err = new OwlError(`Failed to compile ${nameStr}: ${originalError.message}\\n\\ngenerated code:\\nfunction(app, bdom, helpers) {\\n${code}\\n}`);\r\n        err.cause = originalError;\r\n        throw err;\r\n    }\r\n}\n\n// do not modify manually. This file is generated by the release script.\r\nconst version = \"2.8.1\";\n\n// -----------------------------------------------------------------------------\r\n//  Scheduler\r\n// -----------------------------------------------------------------------------\r\nclass Scheduler {\r\n    constructor() {\r\n        this.tasks = new Set();\r\n        this.frame = 0;\r\n        this.delayedRenders = [];\r\n        this.cancelledNodes = new Set();\r\n        this.processing = false;\r\n        this.requestAnimationFrame = Scheduler.requestAnimationFrame;\r\n    }\r\n    addFiber(fiber) {\r\n        this.tasks.add(fiber.root);\r\n    }\r\n    scheduleDestroy(node) {\r\n        this.cancelledNodes.add(node);\r\n        if (this.frame === 0) {\r\n            this.frame = this.requestAnimationFrame(() => this.processTasks());\r\n        }\r\n    }\r\n    /**\r\n     * Process all current tasks. This only applies to the fibers that are ready.\r\n     * Other tasks are left unchanged.\r\n     */\r\n    flush() {\r\n        if (this.delayedRenders.length) {\r\n            let renders = this.delayedRenders;\r\n            this.delayedRenders = [];\r\n            for (let f of renders) {\r\n                if (f.root && f.node.status !== 3 /* DESTROYED */ && f.node.fiber === f) {\r\n                    f.render();\r\n                }\r\n            }\r\n        }\r\n        if (this.frame === 0) {\r\n            this.frame = this.requestAnimationFrame(() => this.processTasks());\r\n        }\r\n    }\r\n    processTasks() {\r\n        if (this.processing) {\r\n            return;\r\n        }\r\n        this.processing = true;\r\n        this.frame = 0;\r\n        for (let node of this.cancelledNodes) {\r\n            node._destroy();\r\n        }\r\n        this.cancelledNodes.clear();\r\n        for (let task of this.tasks) {\r\n            this.processFiber(task);\r\n        }\r\n        for (let task of this.tasks) {\r\n            if (task.node.status === 3 /* DESTROYED */) {\r\n                this.tasks.delete(task);\r\n            }\r\n        }\r\n        this.processing = false;\r\n    }\r\n    processFiber(fiber) {\r\n        if (fiber.root !== fiber) {\r\n            this.tasks.delete(fiber);\r\n            return;\r\n        }\r\n        const hasError = fibersInError.has(fiber);\r\n        if (hasError && fiber.counter !== 0) {\r\n            this.tasks.delete(fiber);\r\n            return;\r\n        }\r\n        if (fiber.node.status === 3 /* DESTROYED */) {\r\n            this.tasks.delete(fiber);\r\n            return;\r\n        }\r\n        if (fiber.counter === 0) {\r\n            if (!hasError) {\r\n                fiber.complete();\r\n            }\r\n            // at this point, the fiber should have been applied to the DOM, so we can\r\n            // remove it from the task list. If it is not the case, it means that there\r\n            // was an error and an error handler triggered a new rendering that recycled\r\n            // the fiber, so in that case, we actually want to keep the fiber around,\r\n            // otherwise it will just be ignored.\r\n            if (fiber.appliedToDom) {\r\n                this.tasks.delete(fiber);\r\n            }\r\n        }\r\n    }\r\n}\r\n// capture the value of requestAnimationFrame as soon as possible, to avoid\r\n// interactions with other code, such as test frameworks that override them\r\nScheduler.requestAnimationFrame = window.requestAnimationFrame.bind(window);\n\nlet hasBeenLogged = false;\r\nconst apps = new Set();\r\nwindow.__OWL_DEVTOOLS__ || (window.__OWL_DEVTOOLS__ = { apps, Fiber, RootFiber, toRaw, reactive });\r\nclass App extends TemplateSet {\r\n    constructor(Root, config = {}) {\r\n        super(config);\r\n        this.scheduler = new Scheduler();\r\n        this.subRoots = new Set();\r\n        this.root = null;\r\n        this.name = config.name || \"\";\r\n        this.Root = Root;\r\n        apps.add(this);\r\n        if (config.test) {\r\n            this.dev = true;\r\n        }\r\n        this.warnIfNoStaticProps = config.warnIfNoStaticProps || false;\r\n        if (this.dev && !config.test && !hasBeenLogged) {\r\n            console.info(`Owl is running in 'dev' mode.`);\r\n            hasBeenLogged = true;\r\n        }\r\n        const env = config.env || {};\r\n        const descrs = Object.getOwnPropertyDescriptors(env);\r\n        this.env = Object.freeze(Object.create(Object.getPrototypeOf(env), descrs));\r\n        this.props = config.props || {};\r\n    }\r\n    mount(target, options) {\r\n        const root = this.createRoot(this.Root, { props: this.props });\r\n        this.root = root.node;\r\n        this.subRoots.delete(root.node);\r\n        return root.mount(target, options);\r\n    }\r\n    createRoot(Root, config = {}) {\r\n        const props = config.props || {};\r\n        // hack to make sure the sub root get the sub env if necessary. for owl 3,\r\n        // would be nice to rethink the initialization process to make sure that\r\n        // we can create a ComponentNode and give it explicitely the env, instead\r\n        // of looking it up in the app\r\n        const env = this.env;\r\n        if (config.env) {\r\n            this.env = config.env;\r\n        }\r\n        const restore = saveCurrent();\r\n        const node = this.makeNode(Root, props);\r\n        restore();\r\n        if (config.env) {\r\n            this.env = env;\r\n        }\r\n        this.subRoots.add(node);\r\n        return {\r\n            node,\r\n            mount: (target, options) => {\r\n                App.validateTarget(target);\r\n                if (this.dev) {\r\n                    validateProps(Root, props, { __owl__: { app: this } });\r\n                }\r\n                const prom = this.mountNode(node, target, options);\r\n                return prom;\r\n            },\r\n            destroy: () => {\r\n                this.subRoots.delete(node);\r\n                node.destroy();\r\n                this.scheduler.processTasks();\r\n            },\r\n        };\r\n    }\r\n    makeNode(Component, props) {\r\n        return new ComponentNode(Component, props, this, null, null);\r\n    }\r\n    mountNode(node, target, options) {\r\n        const promise = new Promise((resolve, reject) => {\r\n            let isResolved = false;\r\n            // manually set a onMounted callback.\r\n            // that way, we are independant from the current node.\r\n            node.mounted.push(() => {\r\n                resolve(node.component);\r\n                isResolved = true;\r\n            });\r\n            // Manually add the last resort error handler on the node\r\n            let handlers = nodeErrorHandlers.get(node);\r\n            if (!handlers) {\r\n                handlers = [];\r\n                nodeErrorHandlers.set(node, handlers);\r\n            }\r\n            handlers.unshift((e) => {\r\n                if (!isResolved) {\r\n                    reject(e);\r\n                }\r\n                throw e;\r\n            });\r\n        });\r\n        node.mountComponent(target, options);\r\n        return promise;\r\n    }\r\n    destroy() {\r\n        if (this.root) {\r\n            for (let subroot of this.subRoots) {\r\n                subroot.destroy();\r\n            }\r\n            this.root.destroy();\r\n            this.scheduler.processTasks();\r\n        }\r\n        apps.delete(this);\r\n    }\r\n    createComponent(name, isStatic, hasSlotsProp, hasDynamicPropList, propList) {\r\n        const isDynamic = !isStatic;\r\n        let arePropsDifferent;\r\n        const hasNoProp = propList.length === 0;\r\n        if (hasSlotsProp) {\r\n            arePropsDifferent = (_1, _2) => true;\r\n        }\r\n        else if (hasDynamicPropList) {\r\n            arePropsDifferent = function (props1, props2) {\r\n                for (let k in props1) {\r\n                    if (props1[k] !== props2[k]) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return Object.keys(props1).length !== Object.keys(props2).length;\r\n            };\r\n        }\r\n        else if (hasNoProp) {\r\n            arePropsDifferent = (_1, _2) => false;\r\n        }\r\n        else {\r\n            arePropsDifferent = function (props1, props2) {\r\n                for (let p of propList) {\r\n                    if (props1[p] !== props2[p]) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            };\r\n        }\r\n        const updateAndRender = ComponentNode.prototype.updateAndRender;\r\n        const initiateRender = ComponentNode.prototype.initiateRender;\r\n        return (props, key, ctx, parent, C) => {\r\n            let children = ctx.children;\r\n            let node = children[key];\r\n            if (isDynamic && node && node.component.constructor !== C) {\r\n                node = undefined;\r\n            }\r\n            const parentFiber = ctx.fiber;\r\n            if (node) {\r\n                if (arePropsDifferent(node.props, props) || parentFiber.deep || node.forceNextRender) {\r\n                    node.forceNextRender = false;\r\n                    updateAndRender.call(node, props, parentFiber);\r\n                }\r\n            }\r\n            else {\r\n                // new component\r\n                if (isStatic) {\r\n                    const components = parent.constructor.components;\r\n                    if (!components) {\r\n                        throw new OwlError(`Cannot find the definition of component \"${name}\", missing static components key in parent`);\r\n                    }\r\n                    C = components[name];\r\n                    if (!C) {\r\n                        throw new OwlError(`Cannot find the definition of component \"${name}\"`);\r\n                    }\r\n                    else if (!(C.prototype instanceof Component)) {\r\n                        throw new OwlError(`\"${name}\" is not a Component. It must inherit from the Component class`);\r\n                    }\r\n                }\r\n                node = new ComponentNode(C, props, this, ctx, key);\r\n                children[key] = node;\r\n                initiateRender.call(node, new Fiber(node, parentFiber));\r\n            }\r\n            parentFiber.childrenMap[key] = node;\r\n            return node;\r\n        };\r\n    }\r\n    handleError(...args) {\r\n        return handleError(...args);\r\n    }\r\n}\r\nApp.validateTarget = validateTarget;\r\nApp.apps = apps;\r\nApp.version = version;\r\nasync function mount(C, target, config = {}) {\r\n    return new App(C, config).mount(target, config);\r\n}\n\nconst mainEventHandler = (data, ev, currentTarget) => {\r\n    const { data: _data, modifiers } = filterOutModifiersFromData(data);\r\n    data = _data;\r\n    let stopped = false;\r\n    if (modifiers.length) {\r\n        let selfMode = false;\r\n        const isSelf = ev.target === currentTarget;\r\n        for (const mod of modifiers) {\r\n            switch (mod) {\r\n                case \"self\":\r\n                    selfMode = true;\r\n                    if (isSelf) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        return stopped;\r\n                    }\r\n                case \"prevent\":\r\n                    if ((selfMode && isSelf) || !selfMode)\r\n                        ev.preventDefault();\r\n                    continue;\r\n                case \"stop\":\r\n                    if ((selfMode && isSelf) || !selfMode)\r\n                        ev.stopPropagation();\r\n                    stopped = true;\r\n                    continue;\r\n            }\r\n        }\r\n    }\r\n    // If handler is empty, the array slot 0 will also be empty, and data will not have the property 0\r\n    // We check this rather than data[0] being truthy (or typeof function) so that it crashes\r\n    // as expected when there is a handler expression that evaluates to a falsy value\r\n    if (Object.hasOwnProperty.call(data, 0)) {\r\n        const handler = data[0];\r\n        if (typeof handler !== \"function\") {\r\n            throw new OwlError(`Invalid handler (expected a function, received: '${handler}')`);\r\n        }\r\n        let node = data[1] ? data[1].__owl__ : null;\r\n        if (node ? node.status === 1 /* MOUNTED */ : true) {\r\n            handler.call(node ? node.component : null, ev);\r\n        }\r\n    }\r\n    return stopped;\r\n};\n\nfunction status(component) {\r\n    switch (component.__owl__.status) {\r\n        case 0 /* NEW */:\r\n            return \"new\";\r\n        case 2 /* CANCELLED */:\r\n            return \"cancelled\";\r\n        case 1 /* MOUNTED */:\r\n            return \"mounted\";\r\n        case 3 /* DESTROYED */:\r\n            return \"destroyed\";\r\n    }\r\n}\n\n// -----------------------------------------------------------------------------\r\n// useRef\r\n// -----------------------------------------------------------------------------\r\n/**\r\n * The purpose of this hook is to allow components to get a reference to a sub\r\n * html node or component.\r\n */\r\nfunction useRef(name) {\r\n    const node = getCurrent();\r\n    const refs = node.refs;\r\n    return {\r\n        get el() {\r\n            const el = refs[name];\r\n            return inOwnerDocument(el) ? el : null;\r\n        },\r\n    };\r\n}\r\n// -----------------------------------------------------------------------------\r\n// useEnv and useSubEnv\r\n// -----------------------------------------------------------------------------\r\n/**\r\n * This hook is useful as a building block for some customized hooks, that may\r\n * need a reference to the env of the component calling them.\r\n */\r\nfunction useEnv() {\r\n    return getCurrent().component.env;\r\n}\r\nfunction extendEnv(currentEnv, extension) {\r\n    const env = Object.create(currentEnv);\r\n    const descrs = Object.getOwnPropertyDescriptors(extension);\r\n    return Object.freeze(Object.defineProperties(env, descrs));\r\n}\r\n/**\r\n * This hook is a simple way to let components use a sub environment.  Note that\r\n * like for all hooks, it is important that this is only called in the\r\n * constructor method.\r\n */\r\nfunction useSubEnv(envExtension) {\r\n    const node = getCurrent();\r\n    node.component.env = extendEnv(node.component.env, envExtension);\r\n    useChildSubEnv(envExtension);\r\n}\r\nfunction useChildSubEnv(envExtension) {\r\n    const node = getCurrent();\r\n    node.childEnv = extendEnv(node.childEnv, envExtension);\r\n}\r\n/**\r\n * This hook will run a callback when a component is mounted and patched, and\r\n * will run a cleanup function before patching and before unmounting the\r\n * the component.\r\n *\r\n * @template T\r\n * @param {Effect<T>} effect the effect to run on component mount and/or patch\r\n * @param {()=>[...T]} [computeDependencies=()=>[NaN]] a callback to compute\r\n *      dependencies that will decide if the effect needs to be cleaned up and\r\n *      run again. If the dependencies did not change, the effect will not run\r\n *      again. The default value returns an array containing only NaN because\r\n *      NaN !== NaN, which will cause the effect to rerun on every patch.\r\n */\r\nfunction useEffect(effect, computeDependencies = () => [NaN]) {\r\n    let cleanup;\r\n    let dependencies;\r\n    onMounted(() => {\r\n        dependencies = computeDependencies();\r\n        cleanup = effect(...dependencies);\r\n    });\r\n    onPatched(() => {\r\n        const newDeps = computeDependencies();\r\n        const shouldReapply = newDeps.some((val, i) => val !== dependencies[i]);\r\n        if (shouldReapply) {\r\n            dependencies = newDeps;\r\n            if (cleanup) {\r\n                cleanup();\r\n            }\r\n            cleanup = effect(...dependencies);\r\n        }\r\n    });\r\n    onWillUnmount(() => cleanup && cleanup());\r\n}\r\n// -----------------------------------------------------------------------------\r\n// useExternalListener\r\n// -----------------------------------------------------------------------------\r\n/**\r\n * When a component needs to listen to DOM Events on element(s) that are not\r\n * part of his hierarchy, we can use the `useExternalListener` hook.\r\n * It will correctly add and remove the event listener, whenever the\r\n * component is mounted and unmounted.\r\n *\r\n * Example:\r\n *  a menu needs to listen to the click on window to be closed automatically\r\n *\r\n * Usage:\r\n *  in the constructor of the OWL component that needs to be notified,\r\n *  `useExternalListener(window, 'click', this._doSomething);`\r\n * */\r\nfunction useExternalListener(target, eventName, handler, eventParams) {\r\n    const node = getCurrent();\r\n    const boundHandler = handler.bind(node.component);\r\n    onMounted(() => target.addEventListener(eventName, boundHandler, eventParams));\r\n    onWillUnmount(() => target.removeEventListener(eventName, boundHandler, eventParams));\r\n}\n\nconfig.shouldNormalizeDom = false;\r\nconfig.mainEventHandler = mainEventHandler;\r\nconst blockDom = {\r\n    config,\r\n    // bdom entry points\r\n    mount: mount$1,\r\n    patch,\r\n    remove,\r\n    // bdom block types\r\n    list,\r\n    multi,\r\n    text,\r\n    toggler,\r\n    createBlock,\r\n    html,\r\n    comment,\r\n};\r\nconst __info__ = {\r\n    version: App.version,\r\n};\n\nTemplateSet.prototype._compileTemplate = function _compileTemplate(name, template) {\r\n    return compile(template, {\r\n        name,\r\n        dev: this.dev,\r\n        translateFn: this.translateFn,\r\n        translatableAttributes: this.translatableAttributes,\r\n        customDirectives: this.customDirectives,\r\n        hasGlobalValues: this.hasGlobalValues,\r\n    });\r\n};\n\nexport { App, Component, EventBus, OwlError, __info__, batched, blockDom, htmlEscape, loadFile, markRaw, markup, mount, onError, onMounted, onPatched, onRendered, onWillDestroy, onWillPatch, onWillRender, onWillStart, onWillUnmount, onWillUpdateProps, reactive, status, toRaw, useChildSubEnv, useComponent, useEffect, useEnv, useExternalListener, useRef, useState, useSubEnv, validate, validateType, whenReady, xml };\n\n\n__info__.date = '2025-09-23T07:17:45.055Z';\n__info__.hash = '5211116';\n__info__.url = 'https://github.com/odoo/owl';\n"],
  "mappings": "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",
  "names": ["words", "document", "capture", "remove", "text", "tagName", "nodeInsertBefore", "mount", "children", "afterNode", "patch", "html", "currentNode", "node", "targets", "target", "bdom", "onError", "fn", "helpers", "callSlot", "key", "value", "name", "xml", "config", "expr", "s", "forceNewBlock", "condition", "on", "el", "Component"]
}
